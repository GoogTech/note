<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.25">
    <link rel="icon" href="icon/favicon.ico"><meta name="author" content="GoogTech"><meta name="keywords" content="GoogTech, 408, CS Course Learning Note, https://goog.tech/note"><title>内存管理 | GoogTech</title><meta name="description" content="GoogTech — CS Course Learning Note">
    <link rel="preload" href="/note/assets/js/runtime~app.cc6e98cd.js" as="script"><link rel="preload" href="/note/assets/css/styles.45c8bbeb.css" as="style"><link rel="preload" href="/note/assets/js/873.a7dae0f7.js" as="script"><link rel="preload" href="/note/assets/js/app.2efb65c3.js" as="script">
    <link rel="stylesheet" href="/note/assets/css/styles.45c8bbeb.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/note/" class=""><img class="logo" src="/note/icon/apple-touch-icon.png" alt="GoogTech"><span class="site-name can-hide">GoogTech</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="408课程"><span class="title">408课程</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="408课程"><span class="title">408课程</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/note/operating-system/README.md" class="nav-link" aria-label="操作系统"><!--[--><!--]--> 操作系统 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/note/data-structure/README.md" class="nav-link" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/note/computer-network/README.md" class="nav-link" aria-label="计算机网络"><!--[--><!--]--> 计算机网络 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/note/computer-compose-principle" class="nav-link" aria-label="计算机组成原理"><!--[--><!--]--> 计算机组成原理 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/googtech/note" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="408课程"><span class="title">408课程</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="408课程"><span class="title">408课程</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/note/operating-system/README.md" class="nav-link" aria-label="操作系统"><!--[--><!--]--> 操作系统 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/note/data-structure/README.md" class="nav-link" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/note/computer-network/README.md" class="nav-link" aria-label="计算机网络"><!--[--><!--]--> 计算机网络 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/note/computer-compose-principle" class="nav-link" aria-label="计算机组成原理"><!--[--><!--]--> 计算机组成原理 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/googtech/note" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item active">介绍</p><ul class=""><li><!--[--><a href="/note/operating-system/" class="nav-link router-link-active sidebar-item" aria-label="操作系统"><!--[--><!--]--> 操作系统 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/note/operating-system/chapter01.html" class="nav-link sidebar-item" aria-label="系统概述"><!--[--><!--]--> 系统概述 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/note/operating-system/chapter02.html" class="nav-link sidebar-item" aria-label="进程管理"><!--[--><!--]--> 进程管理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/note/operating-system/chapter03.html" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-item active" aria-label="内存管理"><!--[--><!--]--> 内存管理 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/note/operating-system/chapter03.html#考查点" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="考查点"><!--[--><!--]--> 考查点 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/note/operating-system/chapter03.html#程序执行过程" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="程序执行过程"><!--[--><!--]--> 程序执行过程 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/note/operating-system/chapter03.html#扩充内存" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="扩充内存"><!--[--><!--]--> 扩充内存 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/note/operating-system/chapter03.html#连续分配" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="连续分配"><!--[--><!--]--> 连续分配 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/note/operating-system/chapter03.html#非连续分配-抽象" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="非连续分配（抽象）"><!--[--><!--]--> 非连续分配（抽象） <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/note/operating-system/chapter03.html#虚拟内存" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="虚拟内存"><!--[--><!--]--> 虚拟内存 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a href="/note/operating-system/chapter04.html" class="nav-link sidebar-item" aria-label="文件管理"><!--[--><!--]--> 文件管理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/note/operating-system/chapter05.html" class="nav-link sidebar-item" aria-label="输入/输出管理"><!--[--><!--]--> 输入/输出管理 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h1><h3 id="考查点" tabindex="-1"><a class="header-anchor" href="#考查点" aria-hidden="true">#</a> 考查点</h3><ul><li><p>考纲内容</p><ul><li><ol><li>内存管理基础</li></ol><ul><li>内存管理概念</li><li>程序装入与链接</li><li>逻辑地址与物理地址空间</li><li>内存保护</li><li>连续与非连续分配管理方式</li></ul></li><li><ol start="2"><li>虚拟内存管理</li></ol><ul><li>虚拟内存的基本概念</li><li>请求分页管理方式</li><li>页面置换算法</li><li>页面分配策略</li><li>抖动与工作集</li></ul></li></ul></li><li><p>复习提示（核心章节）</p><ul><li>内存管理和进程管理是操作系统的核心内容，需重点复习</li></ul></li></ul><h3 id="程序执行过程" tabindex="-1"><a class="header-anchor" href="#程序执行过程" aria-hidden="true">#</a> 程序执行过程</h3><ul><li><p>步骤</p><ul><li><p>编译</p><p>由编译程序将用户源代码编译成若干目标模块（将高级语言翻译为机器语言）</p></li><li><p>链接</p><p>将目标模块及所需的库函数链接在一起, 形成一个完整的装入模块</p><ul><li><p>静态链接</p><ul><li>程序运行前链接成一个完整的装入模块</li></ul></li><li><p>装入时动态链接</p><ul><li>装入内存时边装入边链接</li></ul></li><li><p>运行时动态链接</p><ul><li>程序运行中需要目标模块时才装入并链接</li></ul></li></ul></li><li><p>装入</p><p>由装入程序将装入模块装入内存运行</p><ul><li><p>绝对装入</p><ul><li>编译时产生绝对地址（单道程序阶段，无操作系统）</li></ul></li><li><p>可重定向装入</p><ul><li>装入时将逻辑地址转换为物理地址（早期多道批处理阶段）</li></ul></li><li><p>动态运行时装入</p><ul><li>运行时将逻辑地址转换为物理地址，但需设置重定位寄存器（现代操作系统）</li></ul></li></ul></li><li><p>三步示例图</p><ul><li></li></ul></li></ul></li><li><p>内存保护</p><ul><li><p>目的</p><ul><li>保证各进程在自己的内存空间运行，不会越界访问</li></ul></li><li><p>实现方式</p><ul><li><ol><li>设置上下限寄存器</li></ol></li><li><ol start="2"><li>利用重定位寄存器、界地址寄存器进行判断</li></ol></li></ul></li></ul></li><li><p>逻辑地址与物理地址</p><ul><li><p>逻辑地址</p><ul><li>编译后，每个模块从 0 号单元开始编制</li></ul></li><li><p>物理地址</p><ul><li>内存中物理单元的集合，也是地址转换的最终地址</li></ul></li><li><p>地址重定位：将逻辑地址转换为物理地址</p></li></ul></li></ul><h3 id="扩充内存" tabindex="-1"><a class="header-anchor" href="#扩充内存" aria-hidden="true">#</a> 扩充内存</h3><ul><li><p>交换与覆盖</p><p>覆盖与交换技术是在<strong>多道程序环境</strong>中在<strong>逻辑</strong>上扩充内(主)存的两种方法</p><ul><li><p>覆盖</p><ul><li>将用户空间分为固定区和覆盖区，经常活跃的部分放在固定区</li></ul></li><li><p>交换</p><ul><li>通过换入与换出使程序在辅存与内存之间来回移动</li></ul></li><li><p>交换与覆盖之间的区别</p><ul><li>交换技术主要在不同进程（作业）之间进行</li><li>覆盖技术则用于同一个程序或进程中</li></ul></li></ul></li></ul><h3 id="连续分配" tabindex="-1"><a class="header-anchor" href="#连续分配" aria-hidden="true">#</a> 连续分配</h3><p>是指为一个用户程序分配一个<strong>连续</strong>的内存空间</p><ul><li><p>单一连续分配</p><ul><li>仅支持单道程序，内存分为系统区和用户区，用户程序放在用户区</li><li>无外部碎片，有内部碎片</li></ul></li><li><p>固定分区分配</p><ul><li>支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业</li><li>无外部碎片，有内部碎片</li></ul></li><li><p>动态分区分配</p><ul><li><p>算法</p><ul><li><p>首次最佳（First Fit）算法</p></li><li><p>最佳适应（Best Fit）算法</p></li><li><p>最坏适应（Worst Fit）算法</p></li><li><p>邻近适应（Next Fit）算法</p></li><li><p>四种动态分区分配算法的比较示例图</p><ul><li></li></ul></li><li><p>最容易产生最多的内存碎片</p></li></ul></li><li><p>特点</p><ul><li>支持多道程序，在进程装入内存时，根据进程的大小动态地建立分区</li><li>无内部碎片，有外部碎片（可通过“紧凑技术”来解决）</li></ul></li></ul></li><li><p>内部与外部碎片</p><ul><li><p>内部碎片</p><ul><li>分配个某进程的内存区域中，有些部分没有用上</li></ul></li><li><p>外部碎片</p><ul><li>内存中某些空闲分区由于太小而难以利用</li></ul></li></ul></li><li><p>三种内存分区管理方式的比较示例图</p><ul><li></li></ul></li></ul><h3 id="非连续分配-抽象" tabindex="-1"><a class="header-anchor" href="#非连续分配-抽象" aria-hidden="true">#</a> 非连续分配（抽象）</h3><p>允许将一个进程<strong>分散地</strong>装入到许多<strong>不相邻</strong>的分区中, 进而便可以充分地利用内存, 而无需再使用&quot;<strong>紧凑技术</strong>&quot;来解决<strong>外部碎片</strong>的问题</p><ul><li><p>页式存储管理</p><ul><li><p>目的</p><ul><li>尽量避免碎片的产生（固定分区产生内部碎片，动态分区产生外部碎片）</li></ul></li><li><p>页表</p><ul><li>用于实现从页号到物理块号的地址映射</li></ul></li><li><p>地址转换过程</p><ul><li><ol><li>计算出逻辑地址对应的页号</li></ol></li><li><ol start="2"><li>找到对应页面在内存中存放位置</li></ol></li><li><ol start="3"><li>算法逻辑地址对应的页内偏移量</li></ol></li><li><ol start="4"><li>物理地址 = 页面始址 + 页内偏移量</li></ol></li></ul></li><li><p>页号、页内偏移量的计算</p><ul><li></li><li></li></ul></li><li><p>地址变换机构</p><ul><li><p>基本地址变换机构</p><ul><li>用于将逻辑地址转换为内存中的物理地址</li></ul></li><li><p>具有块表的地址变换机构</p><ul><li><p>为基本地址变换机构的改进版本</p></li><li><p>快表</p><p>又称为<strong>联想寄存器(LTB)</strong>, 是一种访问速度比内存快很多的高速缓冲器, 用来存放当前访问<strong>最频繁</strong>的若干页表项, 以加速地址变换过程, 与此对应, 内存中的页表常称为<strong>慢表</strong></p></li></ul></li><li><p>两级页表</p><ul><li>单级页表项必须连续存放，页表过大时需要很大的连续空间</li><li>单级页表在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存</li></ul></li><li><p>两种地址变换机构的比较示例图</p><ul><li></li></ul></li></ul></li><li><p>优缺点</p><ul><li><p>优点</p><ul><li>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</li></ul></li><li><p>缺点</p><ul><li>不方便按照逻辑模块实现信息的共享和保护，对用户、编译系统、连接装配程序等上层不可见</li></ul></li></ul></li><li><p>特点</p><ul><li><p>地址空间是一维的</p></li><li><p>获取一个数据或一条指令至少要访问两次内存</p><p>1.先访问页表, 确定所存取的数据或指令的物理地址 2.根据该地址存取数据或指令</p></li></ul></li></ul></li><li><p>段式存储管理</p><ul><li><p>目的</p><ul><li>提高内存的利用率，提升计算机的性能</li></ul></li><li><p>段表</p><ul><li>记录逻辑段到实际存储地址的映射关系</li></ul></li><li><p>分段</p><ul><li>将地址空间按照程序自身的逻辑关系划分为若干个段，每段从 0 开始（段内连续，段间随意）</li></ul></li><li><p>与分页的区别</p><ul><li><ol><li>分页对用户不可见，分段对用户可见</li></ol></li><li><ol start="2"><li>页是信息的物理单位，段是信息的逻辑单位</li></ol></li><li><ol start="3"><li>分页的地址空间是一维的，分段的地址空间是二维的</li></ol></li><li><ol start="4"><li>分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）</li></ol><p>纯代码(可重入代码) : 即允许多个进程同时访问的代码</p></li><li><ol start="5"><li>分页（单级页表）、分段访问一个逻辑地址都需要两次访问，分段存储中也可以引入快表机构</li></ol></li></ul></li><li><p>优缺点</p><ul><li><p>优点</p><ul><li>很方便按照逻辑模块实现信息的共享和保护</li></ul></li><li><p>缺点</p><ul><li>若段长过大，为其分配很大的连续空间会很不方便，另外，段式管理会产生外部碎片</li></ul></li></ul></li><li><p>可重入程序</p><ul><li>最大的优点是减少了对程序段的调入 / 调出，因此减少了对换数量</li></ul></li><li><p>特点</p><ul><li><p>CPU 每次从内存中取一次数据需要两次访问内存</p><p>1.先从内存查找段表 2.再拼成物理地址后访问内存</p></li><li><p>地址空间是二维的</p></li></ul></li></ul></li><li><p>段页式存储管理</p><ul><li><p>段页式 ﻿ 页式（提供内存的利用率）﻿ 分段（有利于段的共享）</p><p><strong>采用分段方法来分配和管理用户地址空间</strong>, <strong>采用分页方法来管理物理存储空间</strong>. 但它的开销要比段式和页式管理的开销大</p></li><li><p>段表</p><ul><li>每个段对应一个段表项，各段表项长度相同，由段号（隐含）、段表长度、页表存放地址组成</li></ul></li><li><p>页表</p><ul><li>每个页对应一个页表项，各页表项长度相同，由页号（隐含）、页面存放的内存块号组成</li></ul></li><li><p>缺点</p><ul><li>有内部碎片</li></ul></li><li><p>特点</p><ul><li><p>访问一个逻辑地址都需要三次访存</p><p>1.先从内存查询段表 2.再访问内存查询相应的页表 3.最后拼成物理地址后访问内存</p></li><li><p>地址空间是二维的</p></li></ul></li></ul></li><li><p>与区分存储管理的区别</p><ul><li>分页、分段、段页存储管理需要特定的数据结构支持，如页表、段表、为了提高性能，还需要硬件提供快存和地址加法器</li><li>分区存储管理是满足多道程序设计的最简单的存储管理方案，很适合嵌入式等微型设备</li></ul></li></ul><h3 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存" aria-hidden="true">#</a> 虚拟内存</h3><ul><li><p>概念</p><ul><li><p>基于局部性原理</p><ul><li><p>时间局部性</p><ul><li>现在访问的指令、数据，在不久后可能会被再次访问</li></ul></li><li><p>空间局部性</p><ul><li>现在访问的内存单元周围的内存空间，很可能在不久后会被访问</li></ul></li><li><p>高速缓冲技术</p><ul><li>使用频繁的数据放到更高速的存储器中</li></ul></li></ul></li><li><p>特征</p><ul><li>多次性、对换性、虚拟性、离散性</li></ul></li><li><p>实现方式</p><ul><li>请求分页、分段、段页式存储管理</li></ul></li></ul></li><li><p>请求分页</p><p>请求分页存储管理就是为了解决<strong>内存不足</strong>而使用的方法, 它基于<strong>局部性原理</strong>实现了以时间换取空间的目的, 它的主要特点为间接扩充了内存</p><ul><li><p>组成</p><ul><li><p>页表机构</p><ul><li>在基本分页的基础上新增：状态位、访问字段、修改位、外存地址</li></ul></li><li><p>缺页中断机构</p><ul><li>若访问的页面不存在内存中，则产生一个缺页中断（内中断）</li></ul></li><li><p>地址变换机构</p><ul><li>在分页系统地址变换机构的基础上，为实现虚拟内存而新增了某些功能</li></ul></li></ul></li><li><p>页面置换算法</p><ul><li><p>先进先出算法（FIFO）</p></li><li><p>最佳置换算法（OPT）</p><p>是指每次为作业分配内存空间时, 总是找到能满足空间大小需要的<strong>最小</strong>空闲分区给作业, 可以产生最小的内存空闲分区</p></li><li><p>最近最久未使用（LRU）</p></li><li><p>时钟算法（CLOCK）</p></li><li><p>四种页面置换算法的对比示例图</p><ul><li>堆栈类算法（OPT、LRU）不可能出现 Belady 异常，FIFO 算法基于队列实现（与进程实际运行时的规律不适应）</li></ul></li></ul></li><li><p>页面分配策略</p><ul><li>预调页策略（运行前调入）</li><li>请求调页策略（运行时调入）</li></ul></li><li><p>抖动、工作集</p><ul><li><p>抖动</p><ul><li>页面频繁换入换出的现象，主要原因为分配给进程的物理块不够</li></ul></li><li><p>工作集</p><ul><li>在某段时间间隔里，进程实际访问页面的集合，驻留集大小一般不能小于工作集大小</li></ul></li></ul></li></ul></li><li><p>克服传统存储管理方式的缺点</p><ul><li><p>一次性</p><ul><li>作业数据必须一次性全部调入内存</li></ul></li><li><p>驻留性</p><ul><li>作业数据在整个运行期间都会常驻内存</li></ul></li></ul></li></ul><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="nav-link external meta-item-label" href="https://github.com/googtech/note/edit/master/docs/operating-system/chapter03.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">2021/9/29 上午3:04:28</span></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: hi@goog.tech">googtech</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"> ← <a href="/note/operating-system/chapter02.html" class="nav-link" aria-label="进程管理"><!--[--><!--]--> 进程管理 <!--[--><!--]--></a></span><span class="next"><a href="/note/operating-system/chapter04.html" class="nav-link" aria-label="文件管理"><!--[--><!--]--> 文件管理 <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script src="/note/assets/js/runtime~app.cc6e98cd.js" defer></script><script src="/note/assets/js/873.a7dae0f7.js" defer></script><script src="/note/assets/js/app.2efb65c3.js" defer></script>
  </body>
</html>
