"use strict";(self.webpackChunknote_goog_tech=self.webpackChunknote_goog_tech||[]).push([[83],{3631:(l,i,u)=>{u.r(i),u.d(i,{data:()=>p});const p={key:"v-75dbfce6",path:"/data-structure/chapter05.html",title:"树和二叉树",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"考查点",slug:"考查点",children:[]},{level:3,title:"二叉树",slug:"二叉树",children:[]},{level:3,title:"树和森林",slug:"树和森林",children:[]}],filePathRelative:"data-structure/chapter05.md",git:{updatedTime:1632809745e3,contributors:[{name:"googtech",email:"hi@goog.tech",commits:1}]}}},1623:(l,i,u)=>{u.r(i),u.d(i,{default:()=>e});const p=(0,u(6252).uE)('<h1 id="树和二叉树" tabindex="-1"><a class="header-anchor" href="#树和二叉树" aria-hidden="true">#</a> 树和二叉树</h1><h3 id="考查点" tabindex="-1"><a class="header-anchor" href="#考查点" aria-hidden="true">#</a> 考查点</h3><ul><li><p>考纲内容</p><ul><li><ol><li>二叉树的定义及特征</li></ol></li><li><ol start="2"><li>二叉树的顺序及链式存储结构</li></ol></li><li><ol start="3"><li>二叉树的遍历</li></ol></li><li><ol start="4"><li>线索二叉树的概念及构造</li></ol></li><li><ol start="5"><li>森林的遍历及和二叉树的转换</li></ol></li><li><ol start="6"><li>二叉排序树、平衡二叉树、哈夫曼树及其编码</li></ol></li></ul></li><li><p>复习提示</p><ul><li>本章多以选择题为主，涉及的算法题常与树的遍历有关</li></ul></li></ul><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h3><ul><li><p>五种基本形态示例图</p><ul><li>特点为每个节点至多只有两颗子树,且子树有左右之分,次序不能任意颠倒.</li></ul></li><li><p>特殊二叉树</p><ul><li><p>满二叉树与完全二叉树</p><ul><li><p>示例图</p><ul><li>主要区别在于(b)若有度为1的节点，则只可能有一个，且该结点只有左孩子而无右孩子</li></ul></li></ul></li><li><p>二叉排序树（BST）</p><p>若二叉排序树的左右子树的高度之差的绝对值不超过<strong>1</strong>，则称其为平衡二叉树.</p><ul><li><p>示例图</p><ul><li>左子树节点值 \ufeff 根节点值 \ufeff 右子树节点值</li></ul></li></ul></li><li><p>平衡二叉树（BBT）</p><ul><li><p>示例图</p><ul><li>树上的任一节点的左右子树的深度只差不超过1</li></ul></li></ul></li></ul></li><li><p>存储结构</p><ul><li><p>顺序存储</p><ul><li><p>示例图</p><ul><li>比较适合存储完全二叉树和满二叉树（最大可能节省存储空间）</li></ul></li></ul></li><li><p>链式存储</p><ul><li><p>示例图</p><ul><li>在含有\ufeff个节点的二叉链表中，含有\ufeff个空链域</li></ul></li></ul></li></ul></li><li><p>操作</p><ul><li><p>遍历</p><ul><li><p>前序遍历</p><ul><li><p>递归法</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li></ul></li><li><p>迭代法</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li></ul></li></ul></li><li><p>中序遍历</p><ul><li><p>递归法</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li></ul></li><li><p>迭代法</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li></ul></li></ul></li><li><p>后序遍历</p><ul><li><p>递归法</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li></ul></li><li><p>迭代法</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li></ul></li></ul></li><li><p>层次遍历</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li><li><p>示例图</p><ul><li>遍历次序为从上到下，从左到右</li></ul></li></ul></li><li><p>三种遍历过程示例图</p><ul><li>🔺🔴🟥分别代表前序遍历、中序遍历、后序遍历</li></ul></li></ul></li><li><p>线索二叉树</p><ul><li><p>目的</p><ul><li>为了加快查找节点前驱和后继的速度</li></ul></li><li><p>公式</p><ul><li>空指针总数为\ufeff，又\ufeff，所以空指针总数为</li></ul></li><li><p>节点结构及标志域</p><ul><li>若无左孩子则lchild指向其前驱节点，若无右孩子则rchild指向其后继节点</li><li>0代表该节点具有左/右孩子节点，反之则表示无左/右孩子节点</li></ul></li><li><p>前、中、后序遍历线索二叉树</p><p>二叉树的<strong>线索化</strong>是将二叉链表中的空指针改为指向前驱或后继的线索.</p><ul><li><p>前序线索二叉树</p><ul><li><p>示例图</p><ul><li></li></ul></li></ul></li><li><p>中序、后序线索二叉树</p><ul><li><p>示例图</p><ul><li></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>应用</p><ul><li><p>排序二叉树（BST）</p><ul><li><p>构造过程</p><ul><li><p>示例图</p><ul><li>设关键字序列为\ufeff，则生成的而二叉排序树如上图所示， 若构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树</li></ul></li></ul></li><li><p>插入节点</p><ul><li><p>示例图</p><ul><li></li></ul></li></ul></li><li><p>删除节点</p><ul><li><p>示例图</p><ul><li>仅需修改指针即可完成插入和删除操作，平均执行时间为</li></ul></li></ul></li></ul></li><li><p>平衡二叉树</p><ul><li><p>插入（平衡调整）</p><p>王道书中调整节点平衡的方法过于繁琐, 建议采用孙老师PPT中讲解的方法(<strong>超级简单</strong>), 就是通过<strong>往上提拉节点</strong>的方式使其保持平衡.</p><ul><li><p>LL平衡旋转（右单旋转）</p><ul><li><p>示例图</p><ul><li>在节点A的左孩子（L）的左子树（L）上插入新节点</li></ul></li></ul></li><li><p>RR平衡旋转（左单旋转）</p><ul><li><p>示例图</p><ul><li>在节点A的右孩子（R）的右子树（R）上插入了新节点</li></ul></li></ul></li><li><p>LR平衡旋转（先左后右旋转）</p><ul><li><p>示例图</p><ul><li>在节点A的左孩子（L）的右子树（R）上插入新节点</li></ul></li></ul></li><li><p>RL平衡旋转（先右后左旋转）</p><ul><li><p>示例图</p><ul><li>在节点A的有孩子（R）的左子树（L）上插入新节点</li></ul></li></ul></li></ul></li><li><p>生成过程</p><ul><li><p>示例图</p><ul><li></li></ul></li></ul></li><li><p>查找</p><ul><li><p>示例图</p><ul><li></li></ul></li></ul></li></ul></li><li><p>哈夫曼树</p><p>也称为最优二叉树, 即为带权路径长度(<strong>WPL</strong>)最小的二叉树.</p><ul><li><p>构造过程</p><ul><li><p>示例图</p><ul><li></li></ul></li></ul></li><li><p>哈夫曼编码</p><p>哈夫曼编码是一种被广泛应用而且非常有效的<strong>数据压缩编码</strong>.</p><p>1.权值为字符出现的频率（或次数） 2.其中边标记为0表示&quot;转向左孩子&quot;，标记为1则表示&quot;转向右孩子&quot;（1或0的表示没有明确规定哟）</p><ul><li><p>示例图</p><ul><li>WPL可视为最终编码得到二进制编码的长度</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="树和森林" tabindex="-1"><a class="header-anchor" href="#树和森林" aria-hidden="true">#</a> 树和森林</h3><ul><li><p>存储结构</p><ul><li><p>顺序存储结构（双亲表示法）</p><ul><li><p>示例图</p><ul><li>便于查找节点的双亲节点，但求节点的孩子节点需要遍历整个结构</li></ul></li></ul></li><li><p>链式存储结构</p><ul><li><p>孩子表示法</p><ul><li><p>示例图</p><ul><li>便于寻找节点的子女节点</li></ul></li></ul></li><li><p>孩子兄弟表示法</p><ul><li><p>示例图</p><ul><li>便于实现树转换为二叉树的操作</li></ul></li></ul></li></ul></li></ul></li><li><p>操作</p><ul><li><p>树与二叉树的转换</p><ul><li><p>示例图</p><ul><li>树转换为二叉树的规则：左孩子右兄弟法</li></ul></li></ul></li><li><p>森林与二叉树的转换</p><ul><li><p>示例图</p><ul><li>先将森林中的每颗树转换成相应的二叉树，然后按一定规则组合各颗二叉树</li></ul></li></ul></li><li><p>树和森林的遍历与二叉树遍历的对应关系</p><ul><li><p>示例图</p><ul><li></li></ul></li></ul></li></ul></li><li><p>应用</p><ul><li><p>并查集是一种简单的集合表示</p><ul><li>：初始化并查集</li><li>：求两个不相交子集合的并集</li><li>：在并查集\ufeff中查找并返回包含元素\ufeff的树的根</li></ul></li></ul></li></ul>',7),e={render:function(l,i){return p}}}}]);