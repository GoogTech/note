"use strict";(self.webpackChunknote_goog_tech=self.webpackChunknote_goog_tech||[]).push([[46],{9202:(t,e,l)=>{l.r(e),l.d(e,{data:()=>n});const n={key:"v-801910a0",path:"/data-structure/chapter02.html",title:"线性表",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"考查点",slug:"考查点",children:[]},{level:3,title:"顺序存储",slug:"顺序存储",children:[]},{level:3,title:"链式存储",slug:"链式存储",children:[]}],filePathRelative:"data-structure/chapter02.md",git:{updatedTime:1632809745e3,contributors:[{name:"googtech",email:"hi@goog.tech",commits:2}]}}},3118:(t,e,l)=>{l.r(e),l.d(e,{default:()=>i});const n=(0,l(6252).uE)('<h1 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表" aria-hidden="true">#</a> 线性表</h1><p>逻辑结构</p><h3 id="考查点" tabindex="-1"><a class="header-anchor" href="#考查点" aria-hidden="true">#</a> 考查点</h3><ul><li><p>考纲内容</p><ul><li><ol><li>线性表的定义和基本操作</li></ol></li><li><ol start="2"><li>线性表的实现（顺序及链式存储）</li></ol></li><li><ol start="3"><li>线性表的应用</li></ol></li><li>注意点：算法题只能用C/C++实现，且要求最优性能（时间及空间复杂度）</li></ul></li><li><p>复习提示</p><ul><li>其为考研命题的重点, 应重点掌握线性表的各种操作（基于两种存储结构）</li></ul></li></ul><h3 id="顺序存储" tabindex="-1"><a class="header-anchor" href="#顺序存储" aria-hidden="true">#</a> 顺序存储</h3><p>存储结构</p><ul><li><p>顺序表</p><p>表中元素的逻辑顺序和物理顺序相同、支持随机访问、存储密度高.</p><ul><li><p>插入算法的平均复杂度为</p></li><li><p>删除算法的平均复杂度为</p></li><li><p>按值查找算法的平均复杂度为</p></li><li><p>线性表的顺序存储结构示例图</p><ul><li></li></ul></li></ul></li></ul><h3 id="链式存储" tabindex="-1"><a class="header-anchor" href="#链式存储" aria-hidden="true">#</a> 链式存储</h3><p>存储结构</p><ul><li>单链表</li></ul><p>不要求逻辑上相邻的元素在物理位置上也相邻, 通过 &quot;链&quot; 建立起数据元素之间的逻辑关系.</p><pre><code>- 节点结构\n\n\t- 示例图\n\n\t\t- \n\n- 头插法\n\n\t- 示例图\n\n\t\t- next = head-&gt;next;  head-&gt;next = newNode;&quot;&gt;\ufeff\n\n- 尾插法\n\n\t- 示例图\n\n\t\t- next = newNode;  tail = newNode;  tail-&gt;next = NULL;&quot;&gt;\ufeff\n\n- 插入节点\n\n\t- 示例图\n\n\t\t- next = p-&gt;next;  p-&gt;next = newNode;&quot;&gt;\ufeff\n\n- 删除节点\n\n\t- 示例图\n\n\t\t- next = q-&gt;next;&quot;&gt;\ufeff\n</code></pre><ul><li>双链表</li></ul><p>双链表有两个指针prior和next, 分别指向其前驱及后继节点, 进而克服了单链表访问某个前驱节点时只能从头遍历的缺点.</p><pre><code>- 插入节点\n\n\t- 示例图\n\n\t\t- next = p-&gt;next;  p-&gt;next-&gt;prior = s;  s-&gt;prior = p;  p-&gt;next = s;&quot;&gt;\ufeff\n\n- 删除节点\n\n\t- 示例图\n\n\t\t- next = q-&gt;next;  q-&gt;next-prior = p;&quot;&gt;\ufeff\n</code></pre><ul><li><p>循环链表</p><ul><li><p>循环单链表</p><p>与单链表的区别在于表中尾节点的指针不是NULL, 而改为指向头节点, 从而整个链表形成了一个环.</p><ul><li><p>示例图</p><ul><li>若常在表头和表尾进行操作, 则不设头节点\ufeff而仅设尾节\ufeff点效率更高.</li></ul></li></ul></li><li><p>循环双链表</p><p>即双向链表与循环链表的结合体.</p><ul><li><p>示例图</p><ul><li>当循环链表为空表时, 其头节点的 \ufeff 域和 \ufeff 域都等于</li></ul></li></ul></li></ul></li><li><p>静态链表</p></li></ul><p>静态链表借助数组来描述线性表存储结构, 节点也有数据域data和指针域next, 与链表中的指针不同的是, 静态链表的指针是节点的相对地址(数组下标), 又称游标.</p><pre><code>- 示例图\n\n\t- 静态链表对于不支持指针的高级语言(如\ufeff), 是一种巧妙的设计方法.\n</code></pre>',18),i={render:function(t,e){return n}}}}]);