"use strict";(self.webpackChunknote_goog_tech=self.webpackChunknote_goog_tech||[]).push([[602],{5626:(l,i,p)=>{p.r(i),p.d(i,{data:()=>u});const u={key:"v-24334e04",path:"/operating-system/chapter03.html",title:"内存管理",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"考查点",slug:"考查点",children:[]},{level:3,title:"程序执行过程",slug:"程序执行过程",children:[]},{level:3,title:"扩充内存",slug:"扩充内存",children:[]},{level:3,title:"连续分配",slug:"连续分配",children:[]},{level:3,title:"非连续分配（抽象）",slug:"非连续分配-抽象",children:[]},{level:3,title:"虚拟内存",slug:"虚拟内存",children:[]}],filePathRelative:"operating-system/chapter03.md",git:{updatedTime:1632884668e3,contributors:[{name:"googtech",email:"hi@goog.tech",commits:1}]}}},4101:(l,i,p)=>{p.r(i),p.d(i,{default:()=>t});const u=(0,p(6252).uE)('<h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h1><h3 id="考查点" tabindex="-1"><a class="header-anchor" href="#考查点" aria-hidden="true">#</a> 考查点</h3><ul><li><p>考纲内容</p><ul><li><ol><li>内存管理基础</li></ol><ul><li>内存管理概念</li><li>程序装入与链接</li><li>逻辑地址与物理地址空间</li><li>内存保护</li><li>连续与非连续分配管理方式</li></ul></li><li><ol start="2"><li>虚拟内存管理</li></ol><ul><li>虚拟内存的基本概念</li><li>请求分页管理方式</li><li>页面置换算法</li><li>页面分配策略</li><li>抖动与工作集</li></ul></li></ul></li><li><p>复习提示（核心章节）</p><ul><li>内存管理和进程管理是操作系统的核心内容，需重点复习</li></ul></li></ul><h3 id="程序执行过程" tabindex="-1"><a class="header-anchor" href="#程序执行过程" aria-hidden="true">#</a> 程序执行过程</h3><ul><li><p>步骤</p><ul><li><p>编译</p><p>由编译程序将用户源代码编译成若干目标模块（将高级语言翻译为机器语言）</p></li><li><p>链接</p><p>将目标模块及所需的库函数链接在一起, 形成一个完整的装入模块</p><ul><li><p>静态链接</p><ul><li>程序运行前链接成一个完整的装入模块</li></ul></li><li><p>装入时动态链接</p><ul><li>装入内存时边装入边链接</li></ul></li><li><p>运行时动态链接</p><ul><li>程序运行中需要目标模块时才装入并链接</li></ul></li></ul></li><li><p>装入</p><p>由装入程序将装入模块装入内存运行</p><ul><li><p>绝对装入</p><ul><li>编译时产生绝对地址（单道程序阶段，无操作系统）</li></ul></li><li><p>可重定向装入</p><ul><li>装入时将逻辑地址转换为物理地址（早期多道批处理阶段）</li></ul></li><li><p>动态运行时装入</p><ul><li>运行时将逻辑地址转换为物理地址，但需设置重定位寄存器（现代操作系统）</li></ul></li></ul></li><li><p>三步示例图</p><ul><li></li></ul></li></ul></li><li><p>内存保护</p><ul><li><p>目的</p><ul><li>保证各进程在自己的内存空间运行，不会越界访问</li></ul></li><li><p>实现方式</p><ul><li><ol><li>设置上下限寄存器</li></ol></li><li><ol start="2"><li>利用重定位寄存器、界地址寄存器进行判断</li></ol></li></ul></li></ul></li><li><p>逻辑地址与物理地址</p><ul><li><p>逻辑地址</p><ul><li>编译后，每个模块从 0 号单元开始编制</li></ul></li><li><p>物理地址</p><ul><li>内存中物理单元的集合，也是地址转换的最终地址</li></ul></li><li><p>地址重定位：将逻辑地址转换为物理地址</p></li></ul></li></ul><h3 id="扩充内存" tabindex="-1"><a class="header-anchor" href="#扩充内存" aria-hidden="true">#</a> 扩充内存</h3><ul><li><p>交换与覆盖</p><p>覆盖与交换技术是在<strong>多道程序环境</strong>中在<strong>逻辑</strong>上扩充内(主)存的两种方法</p><ul><li><p>覆盖</p><ul><li>将用户空间分为固定区和覆盖区，经常活跃的部分放在固定区</li></ul></li><li><p>交换</p><ul><li>通过换入与换出使程序在辅存与内存之间来回移动</li></ul></li><li><p>交换与覆盖之间的区别</p><ul><li>交换技术主要在不同进程（作业）之间进行</li><li>覆盖技术则用于同一个程序或进程中</li></ul></li></ul></li></ul><h3 id="连续分配" tabindex="-1"><a class="header-anchor" href="#连续分配" aria-hidden="true">#</a> 连续分配</h3><p>是指为一个用户程序分配一个<strong>连续</strong>的内存空间</p><ul><li><p>单一连续分配</p><ul><li>仅支持单道程序，内存分为系统区和用户区，用户程序放在用户区</li><li>无外部碎片，有内部碎片</li></ul></li><li><p>固定分区分配</p><ul><li>支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业</li><li>无外部碎片，有内部碎片</li></ul></li><li><p>动态分区分配</p><ul><li><p>算法</p><ul><li><p>首次最佳（First Fit）算法</p></li><li><p>最佳适应（Best Fit）算法</p></li><li><p>最坏适应（Worst Fit）算法</p></li><li><p>邻近适应（Next Fit）算法</p></li><li><p>四种动态分区分配算法的比较示例图</p><ul><li></li></ul></li><li><p>最容易产生最多的内存碎片</p></li></ul></li><li><p>特点</p><ul><li>支持多道程序，在进程装入内存时，根据进程的大小动态地建立分区</li><li>无内部碎片，有外部碎片（可通过“紧凑技术”来解决）</li></ul></li></ul></li><li><p>内部与外部碎片</p><ul><li><p>内部碎片</p><ul><li>分配个某进程的内存区域中，有些部分没有用上</li></ul></li><li><p>外部碎片</p><ul><li>内存中某些空闲分区由于太小而难以利用</li></ul></li></ul></li><li><p>三种内存分区管理方式的比较示例图</p><ul><li></li></ul></li></ul><h3 id="非连续分配-抽象" tabindex="-1"><a class="header-anchor" href="#非连续分配-抽象" aria-hidden="true">#</a> 非连续分配（抽象）</h3><p>允许将一个进程<strong>分散地</strong>装入到许多<strong>不相邻</strong>的分区中, 进而便可以充分地利用内存, 而无需再使用&quot;<strong>紧凑技术</strong>&quot;来解决<strong>外部碎片</strong>的问题</p><ul><li><p>页式存储管理</p><ul><li><p>目的</p><ul><li>尽量避免碎片的产生（固定分区产生内部碎片，动态分区产生外部碎片）</li></ul></li><li><p>页表</p><ul><li>用于实现从页号到物理块号的地址映射</li></ul></li><li><p>地址转换过程</p><ul><li><ol><li>计算出逻辑地址对应的页号</li></ol></li><li><ol start="2"><li>找到对应页面在内存中存放位置</li></ol></li><li><ol start="3"><li>算法逻辑地址对应的页内偏移量</li></ol></li><li><ol start="4"><li>物理地址 = 页面始址 + 页内偏移量</li></ol></li></ul></li><li><p>页号、页内偏移量的计算</p><ul><li></li><li></li></ul></li><li><p>地址变换机构</p><ul><li><p>基本地址变换机构</p><ul><li>用于将逻辑地址转换为内存中的物理地址</li></ul></li><li><p>具有块表的地址变换机构</p><ul><li><p>为基本地址变换机构的改进版本</p></li><li><p>快表</p><p>又称为<strong>联想寄存器(LTB)</strong>, 是一种访问速度比内存快很多的高速缓冲器, 用来存放当前访问<strong>最频繁</strong>的若干页表项, 以加速地址变换过程, 与此对应, 内存中的页表常称为<strong>慢表</strong></p></li></ul></li><li><p>两级页表</p><ul><li>单级页表项必须连续存放，页表过大时需要很大的连续空间</li><li>单级页表在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存</li></ul></li><li><p>两种地址变换机构的比较示例图</p><ul><li></li></ul></li></ul></li><li><p>优缺点</p><ul><li><p>优点</p><ul><li>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</li></ul></li><li><p>缺点</p><ul><li>不方便按照逻辑模块实现信息的共享和保护，对用户、编译系统、连接装配程序等上层不可见</li></ul></li></ul></li><li><p>特点</p><ul><li><p>地址空间是一维的</p></li><li><p>获取一个数据或一条指令至少要访问两次内存</p><p>1.先访问页表, 确定所存取的数据或指令的物理地址 2.根据该地址存取数据或指令</p></li></ul></li></ul></li><li><p>段式存储管理</p><ul><li><p>目的</p><ul><li>提高内存的利用率，提升计算机的性能</li></ul></li><li><p>段表</p><ul><li>记录逻辑段到实际存储地址的映射关系</li></ul></li><li><p>分段</p><ul><li>将地址空间按照程序自身的逻辑关系划分为若干个段，每段从 0 开始（段内连续，段间随意）</li></ul></li><li><p>与分页的区别</p><ul><li><ol><li>分页对用户不可见，分段对用户可见</li></ol></li><li><ol start="2"><li>页是信息的物理单位，段是信息的逻辑单位</li></ol></li><li><ol start="3"><li>分页的地址空间是一维的，分段的地址空间是二维的</li></ol></li><li><ol start="4"><li>分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）</li></ol><p>纯代码(可重入代码) : 即允许多个进程同时访问的代码</p></li><li><ol start="5"><li>分页（单级页表）、分段访问一个逻辑地址都需要两次访问，分段存储中也可以引入快表机构</li></ol></li></ul></li><li><p>优缺点</p><ul><li><p>优点</p><ul><li>很方便按照逻辑模块实现信息的共享和保护</li></ul></li><li><p>缺点</p><ul><li>若段长过大，为其分配很大的连续空间会很不方便，另外，段式管理会产生外部碎片</li></ul></li></ul></li><li><p>可重入程序</p><ul><li>最大的优点是减少了对程序段的调入 / 调出，因此减少了对换数量</li></ul></li><li><p>特点</p><ul><li><p>CPU 每次从内存中取一次数据需要两次访问内存</p><p>1.先从内存查找段表 2.再拼成物理地址后访问内存</p></li><li><p>地址空间是二维的</p></li></ul></li></ul></li><li><p>段页式存储管理</p><ul><li><p>段页式 \ufeff 页式（提供内存的利用率）\ufeff 分段（有利于段的共享）</p><p><strong>采用分段方法来分配和管理用户地址空间</strong>, <strong>采用分页方法来管理物理存储空间</strong>. 但它的开销要比段式和页式管理的开销大</p></li><li><p>段表</p><ul><li>每个段对应一个段表项，各段表项长度相同，由段号（隐含）、段表长度、页表存放地址组成</li></ul></li><li><p>页表</p><ul><li>每个页对应一个页表项，各页表项长度相同，由页号（隐含）、页面存放的内存块号组成</li></ul></li><li><p>缺点</p><ul><li>有内部碎片</li></ul></li><li><p>特点</p><ul><li><p>访问一个逻辑地址都需要三次访存</p><p>1.先从内存查询段表 2.再访问内存查询相应的页表 3.最后拼成物理地址后访问内存</p></li><li><p>地址空间是二维的</p></li></ul></li></ul></li><li><p>与区分存储管理的区别</p><ul><li>分页、分段、段页存储管理需要特定的数据结构支持，如页表、段表、为了提高性能，还需要硬件提供快存和地址加法器</li><li>分区存储管理是满足多道程序设计的最简单的存储管理方案，很适合嵌入式等微型设备</li></ul></li></ul><h3 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存" aria-hidden="true">#</a> 虚拟内存</h3><ul><li><p>概念</p><ul><li><p>基于局部性原理</p><ul><li><p>时间局部性</p><ul><li>现在访问的指令、数据，在不久后可能会被再次访问</li></ul></li><li><p>空间局部性</p><ul><li>现在访问的内存单元周围的内存空间，很可能在不久后会被访问</li></ul></li><li><p>高速缓冲技术</p><ul><li>使用频繁的数据放到更高速的存储器中</li></ul></li></ul></li><li><p>特征</p><ul><li>多次性、对换性、虚拟性、离散性</li></ul></li><li><p>实现方式</p><ul><li>请求分页、分段、段页式存储管理</li></ul></li></ul></li><li><p>请求分页</p><p>请求分页存储管理就是为了解决<strong>内存不足</strong>而使用的方法, 它基于<strong>局部性原理</strong>实现了以时间换取空间的目的, 它的主要特点为间接扩充了内存</p><ul><li><p>组成</p><ul><li><p>页表机构</p><ul><li>在基本分页的基础上新增：状态位、访问字段、修改位、外存地址</li></ul></li><li><p>缺页中断机构</p><ul><li>若访问的页面不存在内存中，则产生一个缺页中断（内中断）</li></ul></li><li><p>地址变换机构</p><ul><li>在分页系统地址变换机构的基础上，为实现虚拟内存而新增了某些功能</li></ul></li></ul></li><li><p>页面置换算法</p><ul><li><p>先进先出算法（FIFO）</p></li><li><p>最佳置换算法（OPT）</p><p>是指每次为作业分配内存空间时, 总是找到能满足空间大小需要的<strong>最小</strong>空闲分区给作业, 可以产生最小的内存空闲分区</p></li><li><p>最近最久未使用（LRU）</p></li><li><p>时钟算法（CLOCK）</p></li><li><p>四种页面置换算法的对比示例图</p><ul><li>堆栈类算法（OPT、LRU）不可能出现 Belady 异常，FIFO 算法基于队列实现（与进程实际运行时的规律不适应）</li></ul></li></ul></li><li><p>页面分配策略</p><ul><li>预调页策略（运行前调入）</li><li>请求调页策略（运行时调入）</li></ul></li><li><p>抖动、工作集</p><ul><li><p>抖动</p><ul><li>页面频繁换入换出的现象，主要原因为分配给进程的物理块不够</li></ul></li><li><p>工作集</p><ul><li>在某段时间间隔里，进程实际访问页面的集合，驻留集大小一般不能小于工作集大小</li></ul></li></ul></li></ul></li><li><p>克服传统存储管理方式的缺点</p><ul><li><p>一次性</p><ul><li>作业数据必须一次性全部调入内存</li></ul></li><li><p>驻留性</p><ul><li>作业数据在整个运行期间都会常驻内存</li></ul></li></ul></li></ul>',15),t={render:function(l,i){return u}}}}]);