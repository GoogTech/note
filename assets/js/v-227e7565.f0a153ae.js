"use strict";(self.webpackChunknote_goog_tech=self.webpackChunknote_goog_tech||[]).push([[527],{3278:(l,i,p)=>{p.r(i),p.d(i,{data:()=>u});const u={key:"v-227e7565",path:"/operating-system/chapter02.html",title:"进程管理",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"考查点",slug:"考查点",children:[]},{level:3,title:"进程",slug:"进程",children:[]},{level:3,title:"线程",slug:"线程",children:[]},{level:3,title:"处理机调度",slug:"处理机调度",children:[]},{level:3,title:"进程同步",slug:"进程同步",children:[]},{level:3,title:"死锁",slug:"死锁",children:[]}],filePathRelative:"operating-system/chapter02.md",git:{updatedTime:1632884668e3,contributors:[{name:"googtech",email:"hi@goog.tech",commits:2}]}}},4059:(l,i,p)=>{p.r(i),p.d(i,{default:()=>t});const u=(0,p(6252).uE)('<h1 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理" aria-hidden="true">#</a> 进程管理</h1><h3 id="考查点" tabindex="-1"><a class="header-anchor" href="#考查点" aria-hidden="true">#</a> 考查点</h3><ul><li><p>考纲内容</p><ul><li><ol><li>进程与线程</li></ol></li><li><ol start="2"><li>处理及调度</li></ol></li><li><ol start="3"><li>进程同步</li></ol></li><li><ol start="4"><li>死锁</li></ol></li></ul></li><li><p>复习提示（核心章节）</p><ul><li>重点复习进程的概念、进程调度、信号量机制实现同步与互斥、进程死锁</li></ul></li></ul><h3 id="进程" tabindex="-1"><a class="header-anchor" href="#进程" aria-hidden="true">#</a> 进程</h3><ul><li><p>与程序的区别</p><ul><li><ol><li>程序是永久的，而进程是暂时存在的</li></ol></li><li><ol start="2"><li>程序是静态的（二进制代码），而进程是动态的（对应程序的执行过程）</li></ol></li><li><ol start="3"><li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（传统操作系统）</li></ol></li><li>程序与进程为一对多关系</li></ul></li><li><p>特征</p><ul><li><p>动态性</p><ul><li>进程是程序的一次执行过程，具有一定的生命周期</li><li>进程最重要的特征</li></ul></li><li><p>并发性</p><ul><li>多个进程能在一段时间内同时运行</li></ul></li><li><p>独立性</p><ul><li>进程是能独立运行、独立获取资源、独立接受调度的基本单位</li></ul></li><li><p>异步性</p><ul><li>进程按各自独立的、不可预知的速度向前推进</li><li>异步问题导致的不确定性可通过进程同步机制来解决</li></ul></li><li><p>结构性</p><ul><li>进程实体由程序段、数据段和进程控制块PCB三部分组成，其中PCB是进程存在的唯一标识</li></ul></li></ul></li><li><p>状态</p><ul><li><p>运行状态</p><ul><li>CPU✅，其它所需资源✅</li></ul></li><li><p>就绪状态</p><ul><li>CPU❌，其它所需资源✅</li></ul></li><li><p>阻塞状态</p><ul><li>CPU❌，其它所需资源❌</li></ul></li><li><p>创建状态</p><ul><li>操作系统为新进程分配资源，创建PCB</li></ul></li><li><p>终止状态</p><ul><li>操作系统回收进程的资源，撤销PCB</li></ul></li><li><p>进程状态间的转换</p><ul><li><p>就绪态 ——&gt; 运行态</p><ul><li>进程被调度</li></ul></li><li><p>运行态 ——&gt; 就绪态</p><ul><li>时间片到，或CPU被其它高优先级的进程抢占</li></ul></li><li><p>运行态 ——&gt; 阻塞态</p><ul><li>等待系统资源分配，或等待某事件发生（主动行为）</li></ul></li><li><p>阻塞态 ——&gt; 就绪态</p><ul><li>资源分配到位，等待的事件发生（被动行为）</li></ul></li><li><p>创建态 ——&gt; 就绪态</p><ul><li>系统完成创建相关的工作</li></ul></li><li><p>运行态 ——&gt; 终止态</p><ul><li>进程运行结束，或运行过程中遇到不可修复的错误</li></ul></li></ul></li><li><p>新建、就绪、阻塞、运行、终止状态示例图</p><ul><li>运行态——&gt;阻塞态是主动的行为，而阻塞态——&gt;就绪态是被动的行为，且需要其它进程的协助</li></ul></li></ul></li><li><p>控制</p><p>一般将控制进程的<strong>程序段</strong>称为<strong>原语</strong></p><ul><li><p>概念</p><ul><li><p>进程控制就是要实现进程状态的转换</p></li><li><p>原语</p><ul><li>执行期间不允许中断，它是一个不可分割的基本单位</li><li>使用开中断及关中断指令实现（运行在核心态下的特权指令），是一种特殊的程序</li></ul></li></ul></li><li><p>进程的创建（创建原语）</p><ul><li><p>过程</p><ul><li>1.申请空白PCB</li><li>2.为新进程分配所需资源</li><li>3.初始化PCB</li><li>4.将PCB插入就绪队列</li></ul></li><li><p>引发进程创建的事件</p><ul><li>用户登录、作业调度、提供服务、应用请求</li></ul></li></ul></li><li><p>进程的终止（撤销原语）</p><ul><li><p>过程</p><ul><li>1.从PCB集合中找到终止进程的PCB</li><li>2.若进程正在运行，立即剥夺CPU，将CPU分配给其它进程</li><li>3.终止其所有子进程</li><li>4.将该进程拥有的所有资源归还给父进程或操作系统</li><li>5.删除PCB</li></ul></li><li><p>引发进程终止的事件</p><ul><li>正常结束、异常结束、外界干预</li></ul></li></ul></li><li><p>进程的阻塞和唤醒（阻塞原语 Block）</p><p>Block原语和Wakeup原语是一对作用刚好相反的原语, <strong>必须成对使用</strong>.</p><ul><li><p>过程</p><ul><li>1.找到要阻塞进程对应的PCB</li><li>2.保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>3.将PCB插入相应事件的等待队列</li></ul></li><li><p>引起进程阻塞的事件</p><ul><li>需要等待系统分配某种资源、需要等待相互合作的其它进程完成工作</li></ul></li></ul></li><li><p>进程的唤醒（唤醒原语 Wakeup）</p><ul><li><p>过程</p><ul><li>1.在事件等待队列中找到PCB</li><li>2.将PCB从等待队列移除，设置进程为就绪态</li><li>3.将PCB插入就绪队列，等待被调度</li></ul></li><li><p>引起进程唤醒的事件</p><ul><li>等待的事件发生</li></ul></li></ul></li><li><p>进程的切换（切换原语）</p><ul><li><p>过程</p><ul><li>1.将运行环境信息存入PCB</li><li>2.PCB移入相应队列</li><li>3.选择另一个进程执行，并更新其PCB</li><li>4.根据PCB恢复新进程所需的运行环境</li></ul></li><li><p>引起进程切换的事件</p><ul><li>当前进程时间到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止</li></ul></li></ul></li></ul></li><li><p>组织</p><ul><li><p>程序段</p><ul><li>存放要执行的代码</li></ul></li><li><p>数据段</p><ul><li>存放程序运行过程中处理的各种数据</li></ul></li><li><p>进程控制块PCB</p></li></ul><pre><code>PCB(Process Control Block)是进程存在的**唯一**标识\n\n  - 进程描述信息\n\n  \t- 进程标识符PID\n  \t- 用户标识符UID\n\n  - 进程控制和管理信息\n\n  \t- 进程当前状态\n  \t- 进程优先级\n\n  - 资源分配清单\n\n  \t- 程序及数据段指针\n  \t- 键盘、鼠标\n\n  - 处理机相关信息\n\n  \t- 各种存储器值\n\n  - PCB包含内容的示例图\n\n  \t- PCB是进程存在的唯一标识，即系统唯有通过PCB才能感知到该进程的存在.\n</code></pre><ul><li><p>组织形式</p><ul><li><p>链接方式</p><ul><li>按进程状态将PCB分为多个队列</li></ul></li><li><p>索引方式</p><ul><li>按进程状态建立几张索引表，各表指向一个PCB</li></ul></li></ul></li></ul></li><li><p>通信</p><ul><li><p>共享存储</p><ul><li><p>设置一个共享空间，各个进程进行互斥访问</p></li><li><p>两种方式</p><ul><li>低级方式的共享是基于数据结构的共享</li><li>高级方式的共享是基于存储区的共享</li></ul></li></ul></li><li><p>消息传递</p><ul><li><p>通过系统提供“发送信息 / 接受信息”两个原语进行数据交换</p></li><li><p>两种方式</p><ul><li><p>直接通信方式</p><ul><li>消息直接挂到接收方的消息队列中</li></ul></li><li><p>间接通信方式</p></li></ul><pre><code>又称为信箱通信方式\n\n  - 消息先发到中间实体（一般称为信箱）\n</code></pre></li></ul></li><li><p>管道通信</p><ul><li>从管道读数据为一次性操作, 即读后就弃</li><li>只能采用半双工通信, 即某一时刻只能单向传输</li><li>写满时，不能再写，读空时，不能再读. 以及没写时，不能读，每读空，不能写</li><li>实现双向同时通信则需设置两个管道</li></ul></li></ul></li></ul><h3 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h3><ul><li><p>重要属性</p><ul><li>线程是处理机调度的单位，进程是资源分配的单位</li><li>同一进程的各线程共享进程拥有的资源</li><li>同一进程的线程切换不会导致进程切换</li><li>注：在无线程的系统中，进程是资源调度和并发执行的基本单位</li></ul></li><li><p>与线程的区别</p><p>注: 引入线程后, <strong>进程</strong>只作为除<strong>CPU外的系统资源</strong>的分配单元, 而<strong>线程</strong>则作为<strong>处理机</strong>的分配单元</p><ul><li><ol><li>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量</li></ol></li><li><ol start="2"><li>引入线程中的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位</li></ol></li><li><ol start="3"><li>引入线程的目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</li></ol></li><li><ol start="4"><li>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自身仅拥有少量必要的系统资源</li></ol></li></ul></li><li><p>线程实现方式</p><ul><li><p>用户级线程（User-Level Thread，ULT）</p><ul><li>从用户视角看的线程</li></ul></li><li><p>内核级线程（Kernel-Level Thread，KLT）</p><ul><li>从操作系统视角看的线程（内核级线程才是处理机分配的单位）</li></ul></li><li><p>组合方式：上述两种方式的结合</p></li><li><p>用户级和内核级线程的示例图</p><ul><li>ULT的工作由应用程序完成（内核意识不到线程的存在），而KLT的工作则由内核完成（应用程序仅提供一个编程接口）</li></ul></li></ul></li><li><p>多线程模型</p><ul><li><p>多对一模型</p><ul><li>优点：进程管理开销小效率高</li><li>缺点：一个线程阻塞会导致整个进程都被阻塞（并发度低）</li></ul></li><li><p>一对一模型</p><ul><li>优点：进程管理开销大</li><li>缺点：各个线程可分配到多核处理机并行执行（并发度高）</li></ul></li><li><p>多对多模型</p><ul><li>集上述两者之所长</li></ul></li></ul></li></ul><h3 id="处理机调度" tabindex="-1"><a class="header-anchor" href="#处理机调度" aria-hidden="true">#</a> 处理机调度</h3><ul><li><p>基本概念</p><ul><li>为避免进程争用处理机，按某种算法（公平、高效）选择一个进程将处理机分配给它</li></ul></li><li><p>三级调度</p><ul><li><p>高级调度（作业调度）：为进程活动做准备</p></li><li><p>中级调度（内存调度）：使进程正常运行起来</p></li><li><p>低级调度（进程调度）：将暂时不能运行的进程挂起</p><p>挂起又可分为<strong>就绪挂起</strong>和<strong>阻塞挂起</strong>（五状态模型 —&gt; 七状态模型）</p></li><li><p>处理机的三级调度示例图</p><ul><li>中级调度处于作业调度和进程调度（最基本的，不可或缺）之间</li></ul></li><li><p>处理机的三级调度对比示例图</p><ul><li></li></ul></li></ul></li><li><p>方式、切换与过程</p><ul><li><p>切换过程</p><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li><li>重要结论：进程调度、切换是有代价的、并不是调度越频繁、并发度就越高</li></ul></li><li><p>调度方式</p><ul><li><p>剥夺式（抢占方式）</p><ul><li>只能由当前运行的进程主动放弃CPU</li></ul></li><li><p>非剥夺式（非抢占方式）</p><ul><li>可由操作系统剥夺当前进程的CPU使用权</li></ul></li></ul></li></ul></li><li><p>调度准则</p><ul><li><p>CPU利用率</p><ul><li>忙碌时间 / 总时间</li></ul></li><li><p>吞吐量</p><ul><li>总共完成的作业数量 / 总共花了多少时间</li></ul></li><li><p>周转时间</p><ul><li><p>周转时间</p><ul><li>作业完成时间 - 作业提交时间</li></ul></li><li><p>平均周转时间</p><ul><li>各作业周转时间之和 / 作业数</li></ul></li><li><p>带权周转时间</p><ul><li>作业周转时间 / 作业实际运行时间</li></ul></li><li><p>平均带权周转时间</p><ul><li>各作业带权周转时间之和 / 作业数</li></ul></li></ul></li><li><p>等待时间</p><ul><li>指进程处于等处理机状态的时间之和</li><li>平均等待时间 = 进程或作业等待时间的平均值</li></ul></li><li><p>响应时间</p><ul><li>指从用户提交申请到系统首次产生响应所用的时间</li></ul></li></ul></li><li><p>调度算法</p><ul><li><p>先来先服务调度算法（FCFS）</p><ul><li>优点：公平、时间简单</li><li>缺点：对短作业及I/O繁忙型作业不利</li><li>特点：非抢占式、不会导致饥饿</li></ul></li><li><p>短作业优先调度算法（SJF）</p><p>因其能<strong>最小化</strong>等待时间, 故具有<strong>最短的</strong>平均周转时间</p><ul><li>优点：“最短的”平均等待 / 周转时间</li><li>缺点：对长作业不利，可能导致饥饿</li><li>特点：默认为非抢占式（SJF为抢占式），会导致饥饿</li></ul></li><li><p>优先级调度算法</p><p>一般来说, <strong>I/O型</strong>作业的优先权高于<strong>计算型</strong>作业的优先权</p><ul><li><p>优点：区分优先级、适用于实时系统</p></li><li><p>缺点：可能导致饥饿</p></li><li><p>特点：有抢占式及非抢占式、会导致饥饿</p></li><li><p>分类</p><ul><li><p>根据能否抢占正在执行的进程</p><ul><li>非剥夺式优先级调度算法</li><li>剥夺式优先级调度算法</li></ul></li><li><p>根据进程创建后其优先级是否可以改变</p><ul><li>静态优先级</li><li>动态优先级</li></ul></li></ul></li></ul></li><li><p>高响应比优先调度算法（HRRH）</p><ul><li>优点：对先来先服务及短作业优先调度算法的一种综合平衡</li><li>缺点：计算响应比的开销大</li><li>特点：非抢占式、不会导致饥饿</li></ul></li><li><p>时间片轮转调度算法（RR）</p><p>若<strong>时间片</strong>足够大, 以至于所有进程都能在<strong>一个时间片内</strong>执行完毕, 则其退化为<strong>先来先服务调度算法</strong></p><ul><li>优点：公平、适用于分时系统</li><li>缺点：频繁切换具有开销、不区分优先级</li><li>特点：抢占式、不会导致饥饿</li></ul></li><li><p>多级反馈队列调度算法</p><ul><li>优点：对时间片轮转及优先级调度算法的一种综合平衡</li><li>缺点：可能导致饥饿</li><li>特点：抢占式、会导致饥饿</li></ul></li><li><p>五种常见进程调度算法的特点示例图</p><ul><li></li></ul></li><li><p>每个任务都能分配到时间片、流占用CPU，故适合分时操作系统</p></li><li><p>无法达到实时操作系统的及时性需求</p></li><li><p>按照任务的优先级进行调度，适合实时操作系统</p></li></ul></li></ul><h3 id="进程同步" tabindex="-1"><a class="header-anchor" href="#进程同步" aria-hidden="true">#</a> 进程同步</h3><ul><li><p>概念</p><ul><li><p>临界区</p><ul><li>访问临界资源的那段代码</li></ul></li><li><p>临界资源</p><ul><li><p>一次仅允许一个进程使用的资源</p><p>临界资源为<strong>互斥</strong>共享资源，<strong>非共享数据</strong>不属于临界资源</p></li></ul></li><li><p>同步（直接制约关系）</p><ul><li>解决进程异步性所导致的并发程序执行结果不确定性的问题</li><li>使进程之间相互配合地完成工作，遵循一定的先后顺序来推进工作</li></ul></li><li><p>互斥（间接制约关系）</p><ul><li><p>对邻接资源的访问，需要互斥地进行，即同一时间段内只能允许一个进程访问该资源</p></li><li><p>四个部分</p><ul><li>进入区、临界区、退出区、剩余区</li></ul></li><li><p>遵循原则</p><ul><li><p>空闲让进、忙则等待、有限等待、让权等待</p><p>前三个是<strong>互斥机制</strong>必须遵守的原则, 而&quot;让权等待&quot;准则不一定非得实现, 如<strong>Peterson算法</strong></p></li></ul></li></ul></li></ul></li><li><p>实现方法</p><ul><li><p>软件实现的几种算法</p><ul><li><p>单标致法</p><ul><li>在进入区只做“检查”，不上锁</li><li>缺点：不遵循“空闲让进”原则</li></ul></li><li><p>双标志先检查</p><ul><li>在进入区先“检查”后“上锁”，退出区“解锁”</li><li>缺点：不遵循“忙则等待”原则</li></ul></li><li><p>双标志后检查</p><ul><li>在进入区先“加锁”后“检查”，退出区“解锁”</li><li>缺点：不遵循“空闲让进，有限等待”原则，可能导致“饥饿”</li></ul></li><li><p>Peterson 算法</p><ul><li>在进入区“主动争取、主动谦让，检查对方是否想进进、是否谦让”</li><li>缺点：不遵循“让权等待”原则，会发生“忙等”</li></ul></li></ul></li><li><p>硬件实现</p><ul><li><p>中断屏蔽方法</p><ul><li>使用“开 / 关中断”指令实现</li><li>优点：简单高效</li><li>缺点：只适用于单处理机，及操作系统内核进程</li></ul></li><li><p>硬件指令方法</p><ul><li><p>TestAndSet及Swap指令</p><ul><li>优点：实现简单，适用于多处理机环境</li><li>缺点：不满足“让权等待”</li></ul></li></ul></li></ul></li></ul></li><li><p>信号量</p><ul><li><p>原语</p><ul><li>是指完成某种功能且不被分割、不被中断执行的操作序列，通常可有硬件来实现</li><li>只能被标准的原语 wait(S) 及 signal(S) 访问，可记为 P 操作与 V 操作</li></ul></li><li><p>整型信号量</p><ul><li>用一个整型变量作为信号量，数值表示某种资源数</li></ul></li><li><p>记录型信号量</p><p>引入了阻塞机制, 消除了不<strong>让权等待</strong>的情况</p><ul><li>得名于采用了记录型的数据结构，S.value表示某种资源数，S.L指向等待该资源的队列</li><li>P 操作中，一定先 S.value--，之后可能需执行 block 阻塞原语</li><li>V 操作中，一定先 S.value++，之后可能需执行 wakeup 唤醒原语</li></ul></li><li><p>实现进程互斥</p><ul><li>设置互斥信号量，初值为 1</li><li>P、V操作要紧夹使用互斥资源的那个行为，中间不能有其他冗余代码</li></ul></li><li><p>实现进程同步</p><ul><li><p>设置同步信号量，初始值应根据具体情况而定</p><p>若期望的消息尚<strong>未产生</strong>, 则对应的初值应为<strong>0</strong>, 若期望的消息<strong>已存在</strong>, 则信号量的初值应设为一个<strong>非0的正整数</strong></p></li><li><p>若某个行为要用到某种资源，则在这个行为面前 P 这种资源一下</p></li><li><p>若某种行为会提供某种资源，则在这个行为后面 V 这种资源一下</p></li></ul></li></ul></li><li><p>管程</p><ul><li><p>目的</p><ul><li>解决信号量中编写程序困难，且容易因操作不当而导致系统死锁的问题</li></ul></li><li><p>组成</p><ul><li>管程的名称</li><li>共享结构数据说明</li><li>操作数据结构的一组过程（函数）</li><li>对数据结构初始化的语句</li><li>管程很像高级程序语言中的类（Class）</li></ul></li><li><p>特征</p><ul><li>各外部进程 / 线程只能通过管程提供的特定“入口”才能访问共享数据</li><li>每次仅允许一个进程进入管程，从而实现进程互斥</li><li>互斥特性由编译器实现</li></ul></li><li><p>条件变量（阻塞的原因）</p><ul><li>其中 wait / signal 操作类似于信号量中的 P / V 操作</li><li>条件变量没有值，而信号量有值（反应了剩余资源数）</li></ul></li></ul></li><li><p>经典问题</p><ul><li><p>生产者-消费者问题</p><ul><li>生产者-消费者问题是一个同步互斥问题的综合而已</li><li>实现互斥的 P 操作一定要在实现同步的 P 操作之后，两个 V 操作的顺序可以交换</li></ul></li><li><p>读者-写者问题</p><ul><li>为解决复杂的互斥问题提供了一种参考思路</li><li>核心思想在于设置了一个计数器 count 来记录当前正在访问共享文件的读进程数</li></ul></li><li><p>哲学家进餐问题</p><ul><li>每个进程都需要同时持有两个临界资源，故关键点在于解决死锁</li><li>奇数号哲学家先拿左筷、后拿起右筷，而偶数号哲学家刚好相反</li><li>与贪心算法思想（强调争取眼前认为最好的，而不考虑后序结果）相反</li></ul></li><li><p>吸烟者问题</p><ul><li>为解决“可以生产多个产品的单生产者”问题所提供的一种思路</li></ul></li></ul></li></ul><h3 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h3><ul><li><p>概念</p><ul><li><p>死锁的定义</p><ul><li>指多个进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进</li></ul></li><li><p>死锁与饥饿、死循环的区别</p><ul><li><p>死锁：至少是两个进程一起死锁，死锁进程处于阻塞态</p></li><li><p>饥饿：可以有一个进程饥饿，饥饿的进程可能处于阻塞态或就绪态</p><p>饥饿的定义: 由于<strong>长期得不到</strong>想要的<strong>资源</strong>, 某进程<strong>无法向前</strong>推进的现象</p></li><li><p>死循环：指某进程执行过程中一直跳不出某个循环的现象，由程序员负责解决</p></li></ul></li></ul></li><li><p>原因</p><ul><li><p>进程推进顺序非法（时间）</p><ul><li>进程在运行过程中，请求和释放资源的顺序不当</li></ul></li><li><p>系统资源竞争（空间）</p><ul><li>系统所拥有的不可剥夺资源的数目，不足以满足多个进程运行的需要</li></ul></li></ul></li><li><p>条件</p><ul><li><p>互斥条件</p><ul><li>指进程要求分配的资源是排他性的，即最多只能同时供一个进程使用</li></ul></li><li><p>不剥夺条件</p><ul><li>指进程在使用完资源之前，资源不能被强行夺走</li></ul></li><li><p>请求和保持条件</p><ul><li>指进程占有自身本来拥有的资源并要求其它资源</li></ul></li><li><p>循环等待条件</p><ul><li>指存在一种进程资源的循环等待链</li><li>循环等待未必死锁，死锁一定有循环等待</li></ul></li></ul></li><li><p>策略</p><ul><li><p>预防死锁</p><p>破坏死锁产生的四个<strong>必要</strong>条件</p><ul><li><p>破坏互斥条件</p><ul><li>将临界区改造为可共享使用的资源（如SPOOLing技术）</li><li>缺点：可行性不高，很多时间无法破坏互斥条件</li></ul></li><li><p>破坏不剥夺条件</p><ul><li>申请的资源得不到满足时，立即释放拥有的所有资源</li><li>缺点：实现复杂，释放已获得的资源可能造成前一阶段工作的失效</li></ul></li><li><p>破坏请求和保持条件</p><ul><li>在进程运行前一次申请完它所需要的全部资源</li><li>缺点：资源利用率低，可能导致饥饿</li></ul></li><li><p>破坏循环等待条件</p><ul><li>给资源编号，每个进程必须按照编号递增的顺序请求资源</li><li>缺点：不方便增加新设备；造成资源浪费；给用户的编程带来麻烦</li></ul></li></ul></li><li><p>避免死锁</p><p>死锁避免是指避免死锁发生, 即死锁没有发生</p><ul><li><p>在动态分配资源的过程中，用一些算法避免系统进入不安全状态</p><p>1.死锁状态必定是不安全状态 2.并非所有不安全状态都是死锁状态 3.只要系统处于安全状态, 系统便可避免进入死锁状态</p></li><li><p>银行家算法步骤</p><p>注: 银行家算法是一种死锁避免算法, 用于计算动态资源分配的完全性以避免系统进入死锁状态, <strong>不能用于判断系统是否处于死锁</strong></p><ul><li><ol><li>检查此次申请是否超过了之前声明的最大需求数，即</li></ol></li><li><ol start="2"><li>检查此时系统剩余的可用资源是否还能满足这次需求，即</li></ol></li><li><ol start="3"><li>试探着把资源分配给进程 \ufeff，并修改各数据结构中的数值：</li></ol><ul><li></li><li></li><li></li></ul></li><li><ol start="4"><li>用安全性算法检查此次分配后系统是否处于安全状态</li></ol><p>安全性算法步骤: 检查当前的<strong>剩余可用资源</strong>是否能满足某个进程的<strong>最大</strong>需求, 如果可以, 就把该进程加入<strong>安全序列</strong>, 并把该进程持有的所有资源<strong>全部回收</strong>. 不断<strong>重复</strong>上述步骤, 看最终是否能让<strong>所有进程</strong>都加入安全序列.</p></li></ul></li></ul></li><li><p>死锁的检测和解除</p><p>死锁检测是指死锁已出现,要把它检测出来</p><ul><li><p>允许死锁发生，系统负责检测出死锁并将其解除</p></li><li><p>解除方法</p><ul><li>资源剥夺法、撤销进程法、进程回退法</li></ul></li><li><p>检测方法</p><ul><li><p>资源分配图</p><ul><li>由进程（圆圈）、资源（框中的圆）</li><li>请求边（进程到资源的有向边）、分配边（资源到进程的有向边）组成</li></ul></li><li><p>检测算法</p><ul><li><p>依次消除即不阻塞又不孤立进程 \ufeff 的请求边和分配边，直到无边可消</p><p>注: 所谓的<strong>不阻塞</strong>进程是指其申请的<strong>资源数</strong>还足够的进程</p></li><li><p>死锁定理：若资源分配图是不可完全简化的（即最终不能消除图中所有的边），则说明发生了死锁</p></li></ul></li></ul></li></ul></li><li><p>是死锁处理策略中最严苛的一种策略，可确保系统不发生死锁</p></li></ul></li></ul>',13),t={render:function(l,i){return u}}}}]);