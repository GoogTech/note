"use strict";(self.webpackChunknote_goog_tech=self.webpackChunknote_goog_tech||[]).push([[686],{9107:(l,i,e)=>{e.r(i),e.d(i,{data:()=>u});const u={key:"v-7945ae24",path:"/data-structure/chapter04.html",title:"串",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"考查点",slug:"考查点",children:[]},{level:3,title:"基本概念",slug:"基本概念",children:[]},{level:3,title:"存储结构",slug:"存储结构",children:[]},{level:3,title:"模式匹配算法",slug:"模式匹配算法",children:[]}],filePathRelative:"data-structure/chapter04.md",git:{updatedTime:1632809745e3,contributors:[{name:"googtech",email:"hi@goog.tech",commits:1}]}}},9901:(l,i,e)=>{e.r(i),e.d(i,{default:()=>t});const u=(0,e(6252).uE)('<h1 id="串" tabindex="-1"><a class="header-anchor" href="#串" aria-hidden="true">#</a> 串</h1><h3 id="考查点" tabindex="-1"><a class="header-anchor" href="#考查点" aria-hidden="true">#</a> 考查点</h3><ul><li><p>考纲内容</p><ul><li><ol><li>字符串模式匹配</li></ol></li></ul></li><li><p>复习提示</p><ul><li>重点掌握KMP匹配算法的原理及next数组的推理过程</li></ul></li></ul><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><ul><li>子串、主串（包含子串）、空格串（非空串）</li></ul><h3 id="存储结构" tabindex="-1"><a class="header-anchor" href="#存储结构" aria-hidden="true">#</a> 存储结构</h3><ul><li><p>定长顺序存储</p><p>类似于线性表的顺序存储结构, 用一组地址连续的存储单元存储串值的字符序列.</p></li><li><p>堆分配存储</p><p>以一组地址连续的存储单元存放串值的字符序列, 其存储空间是动态分配的.</p></li><li><p>块链存储</p><p>类似于线性表的链式存储结构, 也可采用链式方式存储串值.</p></li></ul><h3 id="模式匹配算法" tabindex="-1"><a class="header-anchor" href="#模式匹配算法" aria-hidden="true">#</a> 模式匹配算法</h3><ul><li><p>BF（暴力匹配）算法</p><p>最坏时间复杂度为O(nm), 实际执行时间近似为O(n + m), 其中n和m分别为主串和模式串的长度.</p><ul><li><p>C++ 代码实现</p><ul><li>最坏的时间复杂度为</li></ul></li></ul></li><li><p>KMP算法</p><p>其为BF算法的改进, 时间复杂度为O(n + m), 主要优点为主串不回溯.</p><ul><li><p>C++ 代码实现</p><ul><li>时间复杂度为</li></ul></li></ul></li><li><p>构建 \ufeff 数组</p><ul><li><p>部分匹配增值表（Partial Match, PM）</p><ul><li><p>示例图</p><ul><li>移动位数 = 已匹配的字符数 - 对应的部分匹配值</li></ul></li></ul></li><li><p>通过 PM 构建 next 数组</p><ul><li><ol><li>PM右移</li></ol><ul><li><p>示例图</p><ul><li>右移后需将 \ufeff 该写为</li></ul></li></ul></li><li><ol start="2"><li>整体 + 1</li></ol><ul><li><p>示例图</p><ul><li>为了使公式简洁故将 \ufeff 数组整体 \ufeff, 进而可将 \ufeff 该写为</li></ul></li></ul></li></ul></li></ul></li><li><p>KMP算法的进一步改进</p><p>引入nextval数组(next数组修正值)是为了解决KMP算法中的缺陷, 即子串在进行<strong>回溯</strong>匹配的过程中可能存在<strong>不必要的重复匹配</strong>问题.</p><ul><li><p>求 \ufeff 的一般步骤</p><ul><li><ol><li>当 j 等于 1 时, \ufeff 赋值为0, 作为特殊标记</li></ol></li><li><ol start="2"><li>当 \ufeff 不等于 \ufeff 时, \ufeff 赋值为</li></ol></li><li><ol start="3"><li>当 \ufeff 等于 \ufeff 时, \ufeff 赋值为</li></ol></li><li><p>示例图</p><ul><li></li></ul></li></ul></li></ul></li></ul>',9),t={render:function(l,i){return u}}}}]);