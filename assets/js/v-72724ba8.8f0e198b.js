"use strict";(self.webpackChunknote_goog_tech=self.webpackChunknote_goog_tech||[]).push([[940],{3665:(l,i,e)=>{e.r(i),e.d(i,{data:()=>a});const a={key:"v-72724ba8",path:"/data-structure/chapter06.html",title:"图",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"考查点",slug:"考查点",children:[]},{level:3,title:"图的基本术语",slug:"图的基本术语",children:[]},{level:3,title:"图结构的存储",slug:"图结构的存储",children:[]},{level:3,title:"图的遍历",slug:"图的遍历",children:[]},{level:3,title:"图的相关应用",slug:"图的相关应用",children:[]}],filePathRelative:"data-structure/chapter06.md",git:{updatedTime:1632809745e3,contributors:[{name:"googtech",email:"hi@goog.tech",commits:1}]}}},614:(l,i,e)=>{e.r(i),e.d(i,{default:()=>u});const a=(0,e(6252).uE)('<h1 id="图" tabindex="-1"><a class="header-anchor" href="#图" aria-hidden="true">#</a> 图</h1><h3 id="考查点" tabindex="-1"><a class="header-anchor" href="#考查点" aria-hidden="true">#</a> 考查点</h3><ul><li><p>考纲内容</p><ul><li><ol><li>图的基本概念</li></ol></li><li><ol start="2"><li>图的存储及基本操作</li></ol></li><li><ol start="3"><li>图的遍历</li></ol></li><li><ol start="4"><li>图的基本应用</li></ol></li></ul></li><li><p>复习提示</p><ul><li>主要掌握深度优先搜索与广度优先搜索，图的相关算法只需掌握其基本思想及实现步骤</li></ul></li></ul><h3 id="图的基本术语" tabindex="-1"><a class="header-anchor" href="#图的基本术语" aria-hidden="true">#</a> 图的基本术语</h3><ul><li>有向图、无向图、简单图、多重图、完全图、子图</li><li>连图、连通图和连通分量、强连通图、强连通分量</li><li>生成树、生成森林、顶点的度、入度、出度、边的权和网</li><li>稠密图、稀疏图、路径、路径长度和回路、简单路径、简单回路、距离、有向树</li></ul><h3 id="图结构的存储" tabindex="-1"><a class="header-anchor" href="#图结构的存储" aria-hidden="true">#</a> 图结构的存储</h3><ul><li><p>邻接矩阵法</p><ul><li>利用二维数组存储顶点之间的邻接关系，具有唯一性及对称性</li></ul></li><li><p>邻接表法</p><ul><li>结合顺序及链式存储方法，节省了邻接矩阵中浪费的存储空间</li></ul></li><li><p>邻接多重表</p><ul><li>是无向图的另一种链式存储结构</li></ul></li><li><p>十字链表</p><ul><li>是有向图的另一种链式存储结构</li></ul></li></ul><h3 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历" aria-hidden="true">#</a> 图的遍历</h3><ul><li>广度优先遍历</li></ul><p>类似于二叉树的层次遍历，需借助一个辅助队列.</p><pre><code>- Java 代码实现\n</code></pre><ul><li>深度优先遍历</li></ul><p>类似于二叉树的先序遍历，需借助一个辅助栈.</p><pre><code>- Java 代码实现\n</code></pre><h3 id="图的相关应用" tabindex="-1"><a class="header-anchor" href="#图的相关应用" aria-hidden="true">#</a> 图的相关应用</h3><ul><li><p>最小生成树</p><ul><li><p>Prim算法</p><p>适用于求解边稠密的的图的最小生成树</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li><li><p>示例图</p><ul><li></li></ul></li></ul></li><li><p>Kruskal算法</p><p>适用于求解边稀疏而顶点较多的图</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li><li><p>示例图</p><ul><li></li></ul></li></ul></li></ul></li><li><p>最短路径</p><ul><li><p>Dijkstra算法</p><p>用于求单源最短路径, 既求图中某一点到其它各顶点的最短路径.(<strong>不允许边上的权值为负</strong>)</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li><li><p>示例图</p><ul><li></li></ul></li></ul></li><li><p>Floyd算法</p><p>用于求每对顶点间的最短路径.(<strong>不允许有包含带负权值的边组成的回路</strong>)</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li><li><p>示例图</p><ul><li></li></ul></li></ul></li></ul></li><li><p>拓扑排序</p><ul><li><p>AOV网</p><p>拓扑排序是对<strong>有向无环图</strong>的顶点的一种排序. (<strong>若原图存在回路, 则表示不存在拓扑排序</strong>)</p><ul><li><p>Java 代码实现</p><ul><li></li></ul></li><li><p>示例图</p><ul><li></li></ul></li></ul></li></ul></li><li><p>关键路径</p><ul><li>AOE网</li></ul></li></ul>',16),u={render:function(l,i){return a}}}}]);