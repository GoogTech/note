# 排序

### 考查点

- 考纲内容

	- 1. 排序的基本概念
	- 2. 插入排序

		- 直接插入排序
		- 折半插入排序
		- 希尔排序

	- 3. 交换排序

		- 冒泡排序
		- 快速排序

	- 4. 选择排序

		- 简单选择排序
		- 堆排序

	- 5. 2路归并排序
	- 6.  基数排序
	- 7. 外部排序
	- 8. 各种排序算法的比较
	- 9. 排序算法的应用

- 复习提示

	- 堆排序、快速排序、归并排序是本章的重难点

### 基本概念

- 稳定性

	- 是指排序后，关键字相同的元素在顺序表中的相对位置是否改变

- 衡量标准

	- 各种排序算法的性质示例图

		- 

### 内部排序

是指排序期间元素全部存放在**内存**中的排序.

- 插入排序

	- 直接插入与折半插入排序

		- 算法思想

		  每次将一个待排序的记录按其关键字大小插入到前面**已排好序的子序列**中，直到全部记录插入完成.

		- 直接插入排序

			- 顺序查找待插入的位置，适用于顺序表及链表

		- 折半插入排序

			- 折半查找待插入的位置，仅适用于顺序表

		- 性能

			- 空间复杂度为﻿
			- 平均时间复杂度为﻿
			- 稳定

		- 图例

			- 

		- Java 代码实现

			- 直接插入排序

				-  

			- 折半插入排序

				- 

	- 希尔排序

		- 算法思想

		  把相隔某个“**增量**”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序.

		-  适用性

			- 仅适用于线性表为顺序存储的情况

		-  性能

			- 空间复杂度为﻿
			- 平均时间复杂度尚未知（数学难题）
			- 不稳定

		-  图例

			-  

		- Java 代码实现

			- 

- 交换排序

	- 冒泡排序

		-  算法思想

		  从后往前(或从前往后)两两比较相邻元素的值, 若为逆序(即**A[i-1] > A[i]**), 则交换它们, 直到序列比较完.

		-  性能

			- 空间复杂度为﻿
			- 平均时间复杂度为﻿
			- 不稳定

		- 注意点

			- 冒泡排序中产生的有序子序列一定是全局有序的（不同于直接插入排序是局部有序的）

		-  图例

			-  

		- Java 代码实现

			- 

	- 快速排序

		- 算法思想

		  1.在待排序的元素中任取一个元素作为基准(通常取第一个, 但最好随机取哈), 称为**基准元素**.
		  2.将待排序的元素进行区分, 比基准元素大的元素放在它的右边, 比其小的放在它的左边.
		  3.对左右两个分区重复以上步骤, 直到所有元素都是有序的.
		  
	- 性能
		
		- 空间复杂度为﻿
			- 平均时间复杂度为﻿
			- 不稳定
		
	- 注意点
		
		-  快排中并不产生有序子序列，每趟排序后会将基准元素放到其最终位置
		
	- 图例
		
		- 
		
	- Java 代码实现
		
		- 
	
- 选择排序

	- 简单选择排序

		- 算法思想

			- 每一趟在待排序元素中选取关键字最小的元素加入有序子序列，总共进行 ﻿ 趟处理

		- 性能

			- 空间复杂度为﻿
			- 平均时间复杂度为﻿
			- 不稳定

		- 适用性

			- 顺序表、链表

		- Java 代码实现

			-  

	- 堆排序

		- 复习完全二叉树的概念

			- 结点 ﻿ 的左孩子是 ﻿，右孩子是 ﻿，父节点为 ﻿
			- 编号 ﻿ 的结点为分支结点

		- 性能

			- 空间夫再度为﻿
			- 平均时间复杂度为﻿
			- 不稳定

		- 区分

			- 大根堆（根 &gt;= 左、右）构造的堆的节点值从上到下依次减小
			- 小根堆（根 &lt;= 左、右）构造的堆的节点值从上到下依次增大

		- 适用性

			- 适用于关键字较多的情况 1000)" contenteditable="false">﻿，例如在1亿个数中选出前100个最大值

		- 图例

			- 

		- Java 代码实现

			- 

- 归并排序

	- 算法思想

		- 将两个或两个以上的有序表组合成一个新的有序表（2路归并为二合一，进而 k 路归并为 k 合一）

	- 性能

		- 空间复杂度为﻿
		- 平均时间复杂度为﻿
		- 稳定

	- 图例

		- 

	- Java 代码实现

		- 

- 基数排序

	- 算法思想

		- 1. 将整个关键字拆分为 d 位（或 "组"）
		- 2. 按照各个关键字位权重递增的次序（如个、十、百）做 d 趟 “分配”和“收集”
		-  3. 分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列，一趟分配耗时 O(n)
		-  4. 收集：把各个队列中的结点依次出队并链接，一趟收集耗时 O(r)

	- 性能

		- 空间复杂度为﻿
		- 时间复杂度为﻿
		- 稳定

	- 注意点

		- 基数排序不能对 ﻿ 和 ﻿ 类型的实数进行排序

	- 图例

		- 初始序列： 109 —> 063 —> 930 —> 589 —> 184 —> 505 —> 269 —> 008 —> 083">﻿

	- Java 代码实现

		- 

- 总结

	-  1. 经过一趟排序后，插入排序、归并排序、希尔排序不能确定一个元素的最终位置
	-  2. 选择排序、归并排序、插入排序、基数排序的比较次数与初始状态无关
	-  3. 算法的使用场景（﻿为元素数目）

		- 3.1 当 ﻿ 较小时建议使用直插或简单选择排序
		- 3.2 当 ﻿ 较大时建议使用快排、堆排序或归并排序
		- 3.3 当 ﻿ 很大，关键字位数较少且可分解时，建议使用基数排序
		- 3.4 当记录本身信息量较大时，为了避免耗费大量时间移动记录，建议使用链表作为存储结构

### 外部排序

是指排序期间元素无法同时存放在内存中, 必须在排序的过程中根据要求不断地在**内、外存**之间移动的排序.

-  多路归并排序（较抽象）
