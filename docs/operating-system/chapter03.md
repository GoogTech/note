# 内存管理

### 考查点

- 考纲内容

	- 1. 内存管理基础

		- 内存管理概念
		- 程序装入与链接
		- 逻辑地址与物理地址空间
		- 内存保护
		- 连续与非连续分配管理方式

	- 2. 虚拟内存管理

		- 虚拟内存的基本概念
		- 请求分页管理方式
		- 页面置换算法
		- 页面分配策略
		- 抖动与工作集

- 复习提示（核心章节）

	- 内存管理和进程管理是操作系统的核心内容，需重点复习

### 程序执行过程

- 步骤

	- 编译

	  由编译程序将用户源代码编译成若干目标模块（将高级语言翻译为机器语言）

	- 链接

	  将目标模块及所需的库函数链接在一起, 形成一个完整的装入模块

		- 静态链接

			- 程序运行前链接成一个完整的装入模块

		- 装入时动态链接

			- 装入内存时边装入边链接

		- 运行时动态链接

			- 程序运行中需要目标模块时才装入并链接

	- 装入

	  由装入程序将装入模块装入内存运行

		- 绝对装入

			- 编译时产生绝对地址（单道程序阶段，无操作系统）

		- 可重定向装入

			- 装入时将逻辑地址转换为物理地址（早期多道批处理阶段）

		- 动态运行时装入

			- 运行时将逻辑地址转换为物理地址，但需设置重定位寄存器（现代操作系统）

	- 三步示例图

		- 

- 内存保护

	- 目的

		- 保证各进程在自己的内存空间运行，不会越界访问

	- 实现方式

		- 1. 设置上下限寄存器
		- 2. 利用重定位寄存器、界地址寄存器进行判断

- 逻辑地址与物理地址

	- 逻辑地址

		- 编译后，每个模块从 0 号单元开始编制

	- 物理地址

		- 内存中物理单元的集合，也是地址转换的最终地址

	- 地址重定位：将逻辑地址转换为物理地址

### 扩充内存

- 交换与覆盖

  覆盖与交换技术是在**多道程序环境**中在**逻辑**上扩充内(主)存的两种方法

	- 覆盖

		- 将用户空间分为固定区和覆盖区，经常活跃的部分放在固定区

	- 交换

		- 通过换入与换出使程序在辅存与内存之间来回移动

	- 交换与覆盖之间的区别

		- 交换技术主要在不同进程（作业）之间进行
		- 覆盖技术则用于同一个程序或进程中

### 连续分配

是指为一个用户程序分配一个**连续**的内存空间

- 单一连续分配

	- 仅支持单道程序，内存分为系统区和用户区，用户程序放在用户区
	- 无外部碎片，有内部碎片

- 固定分区分配

	- 支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业
	- 无外部碎片，有内部碎片

- 动态分区分配

	- 算法

		- 首次最佳（First Fit）算法
		- 最佳适应（Best Fit）算法
		- 最坏适应（Worst Fit）算法
		- 邻近适应（Next Fit）算法
		- 四种动态分区分配算法的比较示例图

			- 

		- 最容易产生最多的内存碎片

	- 特点

		- 支持多道程序，在进程装入内存时，根据进程的大小动态地建立分区
		- 无内部碎片，有外部碎片（可通过“紧凑技术”来解决）

- 内部与外部碎片

	- 内部碎片

		- 分配个某进程的内存区域中，有些部分没有用上

	- 外部碎片

		- 内存中某些空闲分区由于太小而难以利用

- 三种内存分区管理方式的比较示例图

	- 

### 非连续分配（抽象）

允许将一个进程**分散地**装入到许多**不相邻**的分区中, 进而便可以充分地利用内存, 而无需再使用"**紧凑技术**"来解决**外部碎片**的问题

- 页式存储管理

	- 目的

		- 尽量避免碎片的产生（固定分区产生内部碎片，动态分区产生外部碎片）

	- 页表

		- 用于实现从页号到物理块号的地址映射

	- 地址转换过程

		- 1. 计算出逻辑地址对应的页号
		- 2. 找到对应页面在内存中存放位置
		- 3. 算法逻辑地址对应的页内偏移量
		- 4. 物理地址 = 页面始址 + 页内偏移量

	- 页号、页内偏移量的计算

		- ﻿
		- ﻿

	- 地址变换机构

		- 基本地址变换机构

			- 用于将逻辑地址转换为内存中的物理地址

		- 具有块表的地址变换机构

			- 为基本地址变换机构的改进版本
			- 快表

			  又称为**联想寄存器(LTB)**, 是一种访问速度比内存快很多的高速缓冲器, 用来存放当前访问**最频繁**的若干页表项, 以加速地址变换过程, 与此对应, 内存中的页表常称为**慢表**

		- 两级页表

			- 单级页表项必须连续存放，页表过大时需要很大的连续空间
			- 单级页表在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存

		- 两种地址变换机构的比较示例图

			- 

	- 优缺点

		- 优点

			- 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片

		- 缺点

			- 不方便按照逻辑模块实现信息的共享和保护，对用户、编译系统、连接装配程序等上层不可见

	- 特点

		- 地址空间是一维的
		- 获取一个数据或一条指令至少要访问两次内存

		  1.先访问页表, 确定所存取的数据或指令的物理地址
		  2.根据该地址存取数据或指令

- 段式存储管理

	- 目的

		- 提高内存的利用率，提升计算机的性能

	- 段表

		- 记录逻辑段到实际存储地址的映射关系

	- 分段

		- 将地址空间按照程序自身的逻辑关系划分为若干个段，每段从 0 开始（段内连续，段间随意）

	- 与分页的区别

		- 1. 分页对用户不可见，分段对用户可见
		- 2. 页是信息的物理单位，段是信息的逻辑单位
		- 3. 分页的地址空间是一维的，分段的地址空间是二维的
		- 4. 分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）

		  纯代码(可重入代码) : 即允许多个进程同时访问的代码

		- 5. 分页（单级页表）、分段访问一个逻辑地址都需要两次访问，分段存储中也可以引入快表机构

	- 优缺点

		- 优点

			- 很方便按照逻辑模块实现信息的共享和保护

		- 缺点

			- 若段长过大，为其分配很大的连续空间会很不方便，另外，段式管理会产生外部碎片

	- 可重入程序

		- 最大的优点是减少了对程序段的调入 / 调出，因此减少了对换数量

	- 特点

		- CPU 每次从内存中取一次数据需要两次访问内存

		  1.先从内存查找段表
		  2.再拼成物理地址后访问内存

		- 地址空间是二维的

- 段页式存储管理

	- 段页式 ﻿ 页式（提供内存的利用率）﻿ 分段（有利于段的共享）

	  **采用分段方法来分配和管理用户地址空间**, **采用分页方法来管理物理存储空间**. 但它的开销要比段式和页式管理的开销大

	- 段表

		- 每个段对应一个段表项，各段表项长度相同，由段号（隐含）、段表长度、页表存放地址组成

	- 页表

		- 每个页对应一个页表项，各页表项长度相同，由页号（隐含）、页面存放的内存块号组成

	- 缺点

		- 有内部碎片

	- 特点

		- 访问一个逻辑地址都需要三次访存

		  1.先从内存查询段表
		  2.再访问内存查询相应的页表
		  3.最后拼成物理地址后访问内存

		- 地址空间是二维的

- 与区分存储管理的区别

	- 分页、分段、段页存储管理需要特定的数据结构支持，如页表、段表、为了提高性能，还需要硬件提供快存和地址加法器
	- 分区存储管理是满足多道程序设计的最简单的存储管理方案，很适合嵌入式等微型设备

### 虚拟内存

- 概念

	- 基于局部性原理

		- 时间局部性

			- 现在访问的指令、数据，在不久后可能会被再次访问

		- 空间局部性

			- 现在访问的内存单元周围的内存空间，很可能在不久后会被访问

		- 高速缓冲技术

			- 使用频繁的数据放到更高速的存储器中

	- 特征

		- 多次性、对换性、虚拟性、离散性

	- 实现方式

		- 请求分页、分段、段页式存储管理

- 请求分页

  请求分页存储管理就是为了解决**内存不足**而使用的方法, 它基于**局部性原理**实现了以时间换取空间的目的, 它的主要特点为间接扩充了内存

	- 组成

		- 页表机构

			- 在基本分页的基础上新增：状态位、访问字段、修改位、外存地址

		- 缺页中断机构

			- 若访问的页面不存在内存中，则产生一个缺页中断（内中断）

		- 地址变换机构

			- 在分页系统地址变换机构的基础上，为实现虚拟内存而新增了某些功能

	- 页面置换算法

		- 先进先出算法（FIFO）
		- 最佳置换算法（OPT）

		  是指每次为作业分配内存空间时, 总是找到能满足空间大小需要的**最小**空闲分区给作业, 可以产生最小的内存空闲分区

		- 最近最久未使用（LRU）
		- 时钟算法（CLOCK）
		- 四种页面置换算法的对比示例图

			-  堆栈类算法（OPT、LRU）不可能出现 Belady 异常，FIFO 算法基于队列实现（与进程实际运行时的规律不适应）

	- 页面分配策略

		- 预调页策略（运行前调入）
		- 请求调页策略（运行时调入）

	- 抖动、工作集

		- 抖动

			- 页面频繁换入换出的现象，主要原因为分配给进程的物理块不够

		- 工作集

			- 在某段时间间隔里，进程实际访问页面的集合，驻留集大小一般不能小于工作集大小

- 克服传统存储管理方式的缺点

	- 一次性

		- 作业数据必须一次性全部调入内存

	- 驻留性

		- 作业数据在整个运行期间都会常驻内存
