# 进程管理

### 考查点

- 考纲内容

	- 1. 进程与线程
	- 2. 处理及调度
	- 3. 进程同步
	- 4. 死锁

- 复习提示（核心章节）

	- 重点复习进程的概念、进程调度、信号量机制实现同步与互斥、进程死锁

### 进程

- 与程序的区别

	- 1. 程序是永久的，而进程是暂时存在的
	- 2. 程序是静态的（二进制代码），而进程是动态的（对应程序的执行过程）
	- 3. 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（传统操作系统）
	- 程序与进程为一对多关系

- 特征

	-  动态性

		- 进程是程序的一次执行过程，具有一定的生命周期
		- 进程最重要的特征

	-  并发性

		- 多个进程能在一段时间内同时运行

	-  独立性

		- 进程是能独立运行、独立获取资源、独立接受调度的基本单位

	-  异步性

		- 进程按各自独立的、不可预知的速度向前推进
		- 异步问题导致的不确定性可通过进程同步机制来解决

	-  结构性

		- 进程实体由程序段、数据段和进程控制块PCB三部分组成，其中PCB是进程存在的唯一标识

- 状态

	- 运行状态

		- CPU✅，其它所需资源✅

	- 就绪状态

		- CPU❌，其它所需资源✅

	- 阻塞状态

		- CPU❌，其它所需资源❌

	- 创建状态

		- 操作系统为新进程分配资源，创建PCB

	- 终止状态

		- 操作系统回收进程的资源，撤销PCB

	- 进程状态间的转换

		- 就绪态 ——&gt; 运行态

			- 进程被调度

		- 运行态 ——&gt; 就绪态

			- 时间片到，或CPU被其它高优先级的进程抢占

		- 运行态 ——&gt; 阻塞态

			- 等待系统资源分配，或等待某事件发生（主动行为）

		- 阻塞态 ——&gt; 就绪态

			- 资源分配到位，等待的事件发生（被动行为）

		- 创建态 ——&gt; 就绪态

			- 系统完成创建相关的工作

		- 运行态 ——&gt; 终止态

			- 进程运行结束，或运行过程中遇到不可修复的错误

	- 新建、就绪、阻塞、运行、终止状态示例图

		- 运行态——&gt;阻塞态是主动的行为，而阻塞态——&gt;就绪态是被动的行为，且需要其它进程的协助

- 控制

  一般将控制进程的**程序段**称为**原语**

	- 概念

		- 进程控制就是要实现进程状态的转换
		- 原语

			- 执行期间不允许中断，它是一个不可分割的基本单位
			- 使用开中断及关中断指令实现（运行在核心态下的特权指令），是一种特殊的程序

	- 进程的创建（创建原语）

		- 过程

			- 1.申请空白PCB
			- 2.为新进程分配所需资源
			- 3.初始化PCB
			- 4.将PCB插入就绪队列

		- 引发进程创建的事件

			- 用户登录、作业调度、提供服务、应用请求

	- 进程的终止（撤销原语）

		- 过程

			- 1.从PCB集合中找到终止进程的PCB
			- 2.若进程正在运行，立即剥夺CPU，将CPU分配给其它进程
			- 3.终止其所有子进程
			- 4.将该进程拥有的所有资源归还给父进程或操作系统
			- 5.删除PCB

		- 引发进程终止的事件

			- 正常结束、异常结束、外界干预

	- 进程的阻塞和唤醒（阻塞原语 Block）

	  Block原语和Wakeup原语是一对作用刚好相反的原语, **必须成对使用**.

		- 过程

			- 1.找到要阻塞进程对应的PCB
			- 2.保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
			- 3.将PCB插入相应事件的等待队列

		- 引起进程阻塞的事件

			- 需要等待系统分配某种资源、需要等待相互合作的其它进程完成工作

	- 进程的唤醒（唤醒原语 Wakeup）

		- 过程

			- 1.在事件等待队列中找到PCB
			- 2.将PCB从等待队列移除，设置进程为就绪态
			- 3.将PCB插入就绪队列，等待被调度

		- 引起进程唤醒的事件

			- 等待的事件发生

	- 进程的切换（切换原语）

		- 过程

			- 1.将运行环境信息存入PCB
			- 2.PCB移入相应队列
			- 3.选择另一个进程执行，并更新其PCB
			- 4.根据PCB恢复新进程所需的运行环境

		- 引起进程切换的事件

			- 当前进程时间到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止

- 组织

	-  程序段

		- 存放要执行的代码

	-  数据段

		- 存放程序运行过程中处理的各种数据

	-  进程控制块PCB

	  PCB(Process Control Block)是进程存在的**唯一**标识

		- 进程描述信息

			- 进程标识符PID
			- 用户标识符UID

		- 进程控制和管理信息

			- 进程当前状态
			- 进程优先级

		- 资源分配清单

			- 程序及数据段指针
			- 键盘、鼠标

		- 处理机相关信息

			- 各种存储器值

		- PCB包含内容的示例图

			- PCB是进程存在的唯一标识，即系统唯有通过PCB才能感知到该进程的存在.

	- 组织形式

		- 链接方式

			- 按进程状态将PCB分为多个队列

		- 索引方式

			- 按进程状态建立几张索引表，各表指向一个PCB

- 通信

	- 共享存储

		- 设置一个共享空间，各个进程进行互斥访问
		- 两种方式

			- 低级方式的共享是基于数据结构的共享
			- 高级方式的共享是基于存储区的共享

	- 消息传递

		- 通过系统提供“发送信息 / 接受信息”两个原语进行数据交换
		- 两种方式

			-  直接通信方式

				- 消息直接挂到接收方的消息队列中

			-  间接通信方式

			  又称为信箱通信方式

				- 消息先发到中间实体（一般称为信箱）

	- 管道通信

		- 从管道读数据为一次性操作, 即读后就弃
		- 只能采用半双工通信, 即某一时刻只能单向传输
		- 写满时，不能再写，读空时，不能再读. 以及没写时，不能读，每读空，不能写
		- 实现双向同时通信则需设置两个管道

### 线程

- 重要属性

	- 线程是处理机调度的单位，进程是资源分配的单位
	- 同一进程的各线程共享进程拥有的资源
	- 同一进程的线程切换不会导致进程切换
	- 注：在无线程的系统中，进程是资源调度和并发执行的基本单位

- 与线程的区别

  注: 引入线程后, **进程**只作为除**CPU外的系统资源**的分配单元, 而**线程**则作为**处理机**的分配单元

	- 1. 引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量
	- 2. 引入线程中的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位
	- 3. 引入线程的目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能
	- 4. 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自身仅拥有少量必要的系统资源

- 线程实现方式

	- 用户级线程（User-Level Thread，ULT）

		- 从用户视角看的线程

	- 内核级线程（Kernel-Level Thread，KLT）

		- 从操作系统视角看的线程（内核级线程才是处理机分配的单位）

	- 组合方式：上述两种方式的结合
	- 用户级和内核级线程的示例图

		- ULT的工作由应用程序完成（内核意识不到线程的存在），而KLT的工作则由内核完成（应用程序仅提供一个编程接口）

- 多线程模型

	- 多对一模型

		- 优点：进程管理开销小效率高
		- 缺点：一个线程阻塞会导致整个进程都被阻塞（并发度低）

	- 一对一模型

		- 优点：进程管理开销大
		- 缺点：各个线程可分配到多核处理机并行执行（并发度高）

	- 多对多模型

		- 集上述两者之所长

### 处理机调度

- 基本概念

	- 为避免进程争用处理机，按某种算法（公平、高效）选择一个进程将处理机分配给它

- 三级调度

	- 高级调度（作业调度）：为进程活动做准备
	- 中级调度（内存调度）：使进程正常运行起来
	- 低级调度（进程调度）：将暂时不能运行的进程挂起

	  挂起又可分为**就绪挂起**和**阻塞挂起**（五状态模型 —> 七状态模型）

	- 处理机的三级调度示例图

		- 中级调度处于作业调度和进程调度（最基本的，不可或缺）之间

	- 处理机的三级调度对比示例图

		- 

- 方式、切换与过程

	- 切换过程

		- 对原来运行进程各种数据的保存
		- 对新的进程各种数据的恢复
		- 重要结论：进程调度、切换是有代价的、并不是调度越频繁、并发度就越高

	- 调度方式

		- 剥夺式（抢占方式）

			- 只能由当前运行的进程主动放弃CPU

		- 非剥夺式（非抢占方式）

			- 可由操作系统剥夺当前进程的CPU使用权

- 调度准则

	- CPU利用率

		- 忙碌时间 / 总时间

	- 吞吐量

		- 总共完成的作业数量 / 总共花了多少时间

	- 周转时间

		- 周转时间

			- 作业完成时间 - 作业提交时间

		- 平均周转时间

			- 各作业周转时间之和 / 作业数

		- 带权周转时间

			- 作业周转时间 / 作业实际运行时间

		- 平均带权周转时间

			- 各作业带权周转时间之和 / 作业数

	- 等待时间

		- 指进程处于等处理机状态的时间之和
		- 平均等待时间 = 进程或作业等待时间的平均值

	- 响应时间

		- 指从用户提交申请到系统首次产生响应所用的时间

- 调度算法

	- 先来先服务调度算法（FCFS）

		- 优点：公平、时间简单
		- 缺点：对短作业及I/O繁忙型作业不利
		- 特点：非抢占式、不会导致饥饿

	- 短作业优先调度算法（SJF）

	  因其能**最小化**等待时间, 故具有**最短的**平均周转时间

		- 优点：“最短的”平均等待 / 周转时间
		- 缺点：对长作业不利，可能导致饥饿
		- 特点：默认为非抢占式（SJF为抢占式），会导致饥饿

	- 优先级调度算法

	  一般来说, **I/O型**作业的优先权高于**计算型**作业的优先权

		- 优点：区分优先级、适用于实时系统
		- 缺点：可能导致饥饿
		- 特点：有抢占式及非抢占式、会导致饥饿
		- 分类

			- 根据能否抢占正在执行的进程

				- 非剥夺式优先级调度算法
				- 剥夺式优先级调度算法

			- 根据进程创建后其优先级是否可以改变

				- 静态优先级
				- 动态优先级

	- 高响应比优先调度算法（HRRH）

		- 优点：对先来先服务及短作业优先调度算法的一种综合平衡
		- 缺点：计算响应比的开销大
		- 特点：非抢占式、不会导致饥饿

	- 时间片轮转调度算法（RR）

	  若**时间片**足够大, 以至于所有进程都能在**一个时间片内**执行完毕, 则其退化为**先来先服务调度算法**

		- 优点：公平、适用于分时系统
		- 缺点：频繁切换具有开销、不区分优先级
		- 特点：抢占式、不会导致饥饿

	- 多级反馈队列调度算法

		- 优点：对时间片轮转及优先级调度算法的一种综合平衡
		- 缺点：可能导致饥饿
		- 特点：抢占式、会导致饥饿

	- 五种常见进程调度算法的特点示例图

		- 

	- 每个任务都能分配到时间片、流占用CPU，故适合分时操作系统
	- 无法达到实时操作系统的及时性需求
	- 按照任务的优先级进行调度，适合实时操作系统

### 进程同步

- 概念

	- 临界区

		- 访问临界资源的那段代码

	- 临界资源

		- 一次仅允许一个进程使用的资源

		  临界资源为**互斥**共享资源，**非共享数据**不属于临界资源

	- 同步（直接制约关系）

		- 解决进程异步性所导致的并发程序执行结果不确定性的问题
		- 使进程之间相互配合地完成工作，遵循一定的先后顺序来推进工作

	- 互斥（间接制约关系）

		- 对邻接资源的访问，需要互斥地进行，即同一时间段内只能允许一个进程访问该资源
		- 四个部分

			- 进入区、临界区、退出区、剩余区

		- 遵循原则

			- 空闲让进、忙则等待、有限等待、让权等待

			  前三个是**互斥机制**必须遵守的原则, 而"让权等待"准则不一定非得实现, 如**Peterson算法**

- 实现方法

	-  软件实现的几种算法

		- 单标致法

			- 在进入区只做“检查”，不上锁
			- 缺点：不遵循“空闲让进”原则

		- 双标志先检查

			- 在进入区先“检查”后“上锁”，退出区“解锁”
			- 缺点：不遵循“忙则等待”原则

		- 双标志后检查

			- 在进入区先“加锁”后“检查”，退出区“解锁”
			- 缺点：不遵循“空闲让进，有限等待”原则，可能导致“饥饿”

		- Peterson 算法

			- 在进入区“主动争取、主动谦让，检查对方是否想进进、是否谦让”
			- 缺点：不遵循“让权等待”原则，会发生“忙等”

	-  硬件实现

		- 中断屏蔽方法

			- 使用“开 / 关中断”指令实现
			- 优点：简单高效
			- 缺点：只适用于单处理机，及操作系统内核进程

		- 硬件指令方法

			- TestAndSet及Swap指令

				- 优点：实现简单，适用于多处理机环境
				- 缺点：不满足“让权等待”

- 信号量

	- 原语

		- 是指完成某种功能且不被分割、不被中断执行的操作序列，通常可有硬件来实现
		- 只能被标准的原语 wait(S) 及 signal(S) 访问，可记为 P 操作与 V 操作

	- 整型信号量

		- 用一个整型变量作为信号量，数值表示某种资源数

	- 记录型信号量

	  引入了阻塞机制, 消除了不**让权等待**的情况

		- 得名于采用了记录型的数据结构，S.value表示某种资源数，S.L指向等待该资源的队列
		- P 操作中，一定先 S.value--，之后可能需执行 block 阻塞原语
		- V 操作中，一定先 S.value++，之后可能需执行 wakeup 唤醒原语

	- 实现进程互斥

		- 设置互斥信号量，初值为 1
		- P、V操作要紧夹使用互斥资源的那个行为，中间不能有其他冗余代码

	- 实现进程同步

		- 设置同步信号量，初始值应根据具体情况而定

		  若期望的消息尚**未产生**, 则对应的初值应为**0**, 若期望的消息**已存在**, 则信号量的初值应设为一个**非0的正整数**

		- 若某个行为要用到某种资源，则在这个行为面前 P 这种资源一下
		- 若某种行为会提供某种资源，则在这个行为后面 V 这种资源一下

- 管程

	- 目的

		- 解决信号量中编写程序困难，且容易因操作不当而导致系统死锁的问题

	- 组成

		- 管程的名称
		- 共享结构数据说明
		- 操作数据结构的一组过程（函数）
		- 对数据结构初始化的语句
		- 管程很像高级程序语言中的类（Class）

	- 特征

		- 各外部进程 / 线程只能通过管程提供的特定“入口”才能访问共享数据
		- 每次仅允许一个进程进入管程，从而实现进程互斥
		- 互斥特性由编译器实现

	- 条件变量（阻塞的原因）

		- 其中 wait / signal 操作类似于信号量中的 P / V 操作
		- 条件变量没有值，而信号量有值（反应了剩余资源数）

- 经典问题

	-  生产者-消费者问题

		- 生产者-消费者问题是一个同步互斥问题的综合而已
		- 实现互斥的 P 操作一定要在实现同步的 P 操作之后，两个 V 操作的顺序可以交换

	-  读者-写者问题

		- 为解决复杂的互斥问题提供了一种参考思路
		- 核心思想在于设置了一个计数器 count 来记录当前正在访问共享文件的读进程数

	-  哲学家进餐问题

		- 每个进程都需要同时持有两个临界资源，故关键点在于解决死锁
		- 奇数号哲学家先拿左筷、后拿起右筷，而偶数号哲学家刚好相反
		- 与贪心算法思想（强调争取眼前认为最好的，而不考虑后序结果）相反

	-  吸烟者问题

		- 为解决“可以生产多个产品的单生产者”问题所提供的一种思路

### 死锁

- 概念

	- 死锁的定义

		- 指多个进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进

	- 死锁与饥饿、死循环的区别

		- 死锁：至少是两个进程一起死锁，死锁进程处于阻塞态
		- 饥饿：可以有一个进程饥饿，饥饿的进程可能处于阻塞态或就绪态

		  饥饿的定义: 由于**长期得不到**想要的**资源**, 某进程**无法向前**推进的现象

		- 死循环：指某进程执行过程中一直跳不出某个循环的现象，由程序员负责解决

- 原因

	- 进程推进顺序非法（时间）

		- 进程在运行过程中，请求和释放资源的顺序不当

	- 系统资源竞争（空间）

		- 系统所拥有的不可剥夺资源的数目，不足以满足多个进程运行的需要

- 条件

	- 互斥条件

		- 指进程要求分配的资源是排他性的，即最多只能同时供一个进程使用

	- 不剥夺条件

		- 指进程在使用完资源之前，资源不能被强行夺走

	- 请求和保持条件

		- 指进程占有自身本来拥有的资源并要求其它资源

	- 循环等待条件

		- 指存在一种进程资源的循环等待链
		- 循环等待未必死锁，死锁一定有循环等待

- 策略

	- 预防死锁

	  破坏死锁产生的四个**必要**条件

		- 破坏互斥条件

			- 将临界区改造为可共享使用的资源（如SPOOLing技术）
			- 缺点：可行性不高，很多时间无法破坏互斥条件

		- 破坏不剥夺条件

			- 申请的资源得不到满足时，立即释放拥有的所有资源
			- 缺点：实现复杂，释放已获得的资源可能造成前一阶段工作的失效

		- 破坏请求和保持条件

			- 在进程运行前一次申请完它所需要的全部资源
			- 缺点：资源利用率低，可能导致饥饿

		- 破坏循环等待条件

			- 给资源编号，每个进程必须按照编号递增的顺序请求资源
			- 缺点：不方便增加新设备；造成资源浪费；给用户的编程带来麻烦

	- 避免死锁

	  死锁避免是指避免死锁发生, 即死锁没有发生

		- 在动态分配资源的过程中，用一些算法避免系统进入不安全状态

		  1.死锁状态必定是不安全状态
		  2.并非所有不安全状态都是死锁状态
		  3.只要系统处于安全状态, 系统便可避免进入死锁状态

		- 银行家算法步骤

		  注: 银行家算法是一种死锁避免算法, 用于计算动态资源分配的完全性以避免系统进入死锁状态, **不能用于判断系统是否处于死锁**

			- 1. 检查此次申请是否超过了之前声明的最大需求数，即 ﻿
			- 2. 检查此时系统剩余的可用资源是否还能满足这次需求，即 ﻿
			- 3. 试探着把资源分配给进程 ﻿，并修改各数据结构中的数值：

				- ﻿
				- ﻿
				- ﻿

			- 4. 用安全性算法检查此次分配后系统是否处于安全状态

			  安全性算法步骤: 检查当前的**剩余可用资源**是否能满足某个进程的**最大**需求, 如果可以, 就把该进程加入**安全序列**, 并把该进程持有的所有资源**全部回收**.
			  不断**重复**上述步骤, 看最终是否能让**所有进程**都加入安全序列.

	- 死锁的检测和解除

	  死锁检测是指死锁已出现,要把它检测出来

		- 允许死锁发生，系统负责检测出死锁并将其解除
		- 解除方法

			- 资源剥夺法、撤销进程法、进程回退法

		- 检测方法

			- 资源分配图

				- 由进程（圆圈）、资源（框中的圆）
				- 请求边（进程到资源的有向边）、分配边（资源到进程的有向边）组成

			- 检测算法

				- 依次消除即不阻塞又不孤立进程 ﻿ 的请求边和分配边，直到无边可消

				  注: 所谓的**不阻塞**进程是指其申请的**资源数**还足够的进程

				- 死锁定理：若资源分配图是不可完全简化的（即最终不能消除图中所有的边），则说明发生了死锁

	- 是死锁处理策略中最严苛的一种策略，可确保系统不发生死锁
